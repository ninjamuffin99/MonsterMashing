// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix3D
#include <openfl/geom/Matrix3D.h>
#endif
#ifndef INCLUDED_openfl_geom_Vector3D
#include <openfl/geom/Vector3D.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_48294970c42d50e6_20_new,"openfl.geom.Matrix3D","new",0xe0591fd8,"openfl.geom.Matrix3D.new","openfl/geom/Matrix3D.hx",20,0x3acce238)
static const Float _hx_array_data_3d2e93e6_1[] = {
	1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_33_append,"openfl.geom.Matrix3D","append",0x481b8d62,"openfl.geom.Matrix3D.append","openfl/geom/Matrix3D.hx",33,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_67_appendRotation,"openfl.geom.Matrix3D","appendRotation",0xf492b8c0,"openfl.geom.Matrix3D.appendRotation","openfl/geom/Matrix3D.hx",67,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_85_appendScale,"openfl.geom.Matrix3D","appendScale",0x02daedc8,"openfl.geom.Matrix3D.appendScale","openfl/geom/Matrix3D.hx",85,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_90_appendTranslation,"openfl.geom.Matrix3D","appendTranslation",0x514252af,"openfl.geom.Matrix3D.appendTranslation","openfl/geom/Matrix3D.hx",90,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_101_clone,"openfl.geom.Matrix3D","clone",0x2ff530d5,"openfl.geom.Matrix3D.clone","openfl/geom/Matrix3D.hx",101,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_108_copyColumnFrom,"openfl.geom.Matrix3D","copyColumnFrom",0x63600afd,"openfl.geom.Matrix3D.copyColumnFrom","openfl/geom/Matrix3D.hx",108,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_147_copyColumnTo,"openfl.geom.Matrix3D","copyColumnTo",0x8c37304e,"openfl.geom.Matrix3D.copyColumnTo","openfl/geom/Matrix3D.hx",147,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_186_copyFrom,"openfl.geom.Matrix3D","copyFrom",0xe290a947,"openfl.geom.Matrix3D.copyFrom","openfl/geom/Matrix3D.hx",186,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_191_copyRawDataFrom,"openfl.geom.Matrix3D","copyRawDataFrom",0x9938207f,"openfl.geom.Matrix3D.copyRawDataFrom","openfl/geom/Matrix3D.hx",191,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_216_copyRawDataTo,"openfl.geom.Matrix3D","copyRawDataTo",0xac978150,"openfl.geom.Matrix3D.copyRawDataTo","openfl/geom/Matrix3D.hx",216,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_241_copyRowFrom,"openfl.geom.Matrix3D","copyRowFrom",0x3d20cce7,"openfl.geom.Matrix3D.copyRowFrom","openfl/geom/Matrix3D.hx",241,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_280_copyRowTo,"openfl.geom.Matrix3D","copyRowTo",0x42dcc3b8,"openfl.geom.Matrix3D.copyRowTo","openfl/geom/Matrix3D.hx",280,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_319_copyToMatrix3D,"openfl.geom.Matrix3D","copyToMatrix3D",0x2cc9916a,"openfl.geom.Matrix3D.copyToMatrix3D","openfl/geom/Matrix3D.hx",319,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_353_decompose,"openfl.geom.Matrix3D","decompose",0x4a21fd29,"openfl.geom.Matrix3D.decompose","openfl/geom/Matrix3D.hx",353,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_479_deltaTransformVector,"openfl.geom.Matrix3D","deltaTransformVector",0x0285cbbf,"openfl.geom.Matrix3D.deltaTransformVector","openfl/geom/Matrix3D.hx",479,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_490_identity,"openfl.geom.Matrix3D","identity",0xd35ee2c6,"openfl.geom.Matrix3D.identity","openfl/geom/Matrix3D.hx",490,0x3acce238)
static const Float _hx_array_data_3d2e93e6_21[] = {
	1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_512_interpolateTo,"openfl.geom.Matrix3D","interpolateTo",0x74c2e614,"openfl.geom.Matrix3D.interpolateTo","openfl/geom/Matrix3D.hx",512,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_521_invert,"openfl.geom.Matrix3D","invert",0x5820929e,"openfl.geom.Matrix3D.invert","openfl/geom/Matrix3D.hx",521,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_559_pointAt,"openfl.geom.Matrix3D","pointAt",0xd7900cdb,"openfl.geom.Matrix3D.pointAt","openfl/geom/Matrix3D.hx",559,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_626_prepend,"openfl.geom.Matrix3D","prepend",0xbe4f0286,"openfl.geom.Matrix3D.prepend","openfl/geom/Matrix3D.hx",626,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_660_prependRotation,"openfl.geom.Matrix3D","prependRotation",0x54b5f1e4,"openfl.geom.Matrix3D.prependRotation","openfl/geom/Matrix3D.hx",660,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_678_prependScale,"openfl.geom.Matrix3D","prependScale",0x59d85624,"openfl.geom.Matrix3D.prependScale","openfl/geom/Matrix3D.hx",678,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_683_prependTranslation,"openfl.geom.Matrix3D","prependTranslation",0x2df4680b,"openfl.geom.Matrix3D.prependTranslation","openfl/geom/Matrix3D.hx",683,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_692_recompose,"openfl.geom.Matrix3D","recompose",0xd355bb37,"openfl.geom.Matrix3D.recompose","openfl/geom/Matrix3D.hx",692,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_799_transformVector,"openfl.geom.Matrix3D","transformVector",0x3f2dcec7,"openfl.geom.Matrix3D.transformVector","openfl/geom/Matrix3D.hx",799,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_810_transformVectors,"openfl.geom.Matrix3D","transformVectors",0x08e71fcc,"openfl.geom.Matrix3D.transformVectors","openfl/geom/Matrix3D.hx",810,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_832_transpose,"openfl.geom.Matrix3D","transpose",0x1ba989f1,"openfl.geom.Matrix3D.transpose","openfl/geom/Matrix3D.hx",832,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_892_get_determinant,"openfl.geom.Matrix3D","get_determinant",0x5f71b8a4,"openfl.geom.Matrix3D.get_determinant","openfl/geom/Matrix3D.hx",892,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_904_get_position,"openfl.geom.Matrix3D","get_position",0x1555563a,"openfl.geom.Matrix3D.get_position","openfl/geom/Matrix3D.hx",904,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_909_set_position,"openfl.geom.Matrix3D","set_position",0x2a4e79ae,"openfl.geom.Matrix3D.set_position","openfl/geom/Matrix3D.hx",909,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_324_create2D,"openfl.geom.Matrix3D","create2D",0x4623e756,"openfl.geom.Matrix3D.create2D","openfl/geom/Matrix3D.hx",324,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_337_createABCD,"openfl.geom.Matrix3D","createABCD",0x0e55d246,"openfl.geom.Matrix3D.createABCD","openfl/geom/Matrix3D.hx",337,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_342_createOrtho,"openfl.geom.Matrix3D","createOrtho",0xac3dd614,"openfl.geom.Matrix3D.createOrtho","openfl/geom/Matrix3D.hx",342,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_495_interpolate,"openfl.geom.Matrix3D","interpolate",0x6cc85c39,"openfl.geom.Matrix3D.interpolate","openfl/geom/Matrix3D.hx",495,0x3acce238)
HX_LOCAL_STACK_FRAME(_hx_pos_48294970c42d50e6_851___getAxisRotation,"openfl.geom.Matrix3D","__getAxisRotation",0xf649170d,"openfl.geom.Matrix3D.__getAxisRotation","openfl/geom/Matrix3D.hx",851,0x3acce238)
namespace openfl{
namespace geom{

void Matrix3D_obj::__construct(::Array< Float > v){
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_20_new)
HXDLIN(  20)		bool _hx_tmp;
HXDLIN(  20)		if (hx::IsNotNull( v )) {
HXDLIN(  20)			_hx_tmp = (v->length == (int)16);
            		}
            		else {
HXDLIN(  20)			_hx_tmp = false;
            		}
HXDLIN(  20)		if (_hx_tmp) {
HXLINE(  22)			this->rawData = v;
            		}
            		else {
HXLINE(  26)			this->rawData = ::Array_obj< Float >::fromData( _hx_array_data_3d2e93e6_1,16);
            		}
            	}

Dynamic Matrix3D_obj::__CreateEmpty() { return new Matrix3D_obj; }

void *Matrix3D_obj::_hx_vtable = 0;

Dynamic Matrix3D_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Matrix3D_obj > _hx_result = new Matrix3D_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool Matrix3D_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x34742c1e;
}

void Matrix3D_obj::append( ::openfl::geom::Matrix3D lhs){
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_33_append)
HXLINE(  35)		Float m111 = this->rawData->__get((int)0);
HXDLIN(  35)		Float m121 = this->rawData->__get((int)4);
HXDLIN(  35)		Float m131 = this->rawData->__get((int)8);
HXDLIN(  35)		Float m141 = this->rawData->__get((int)12);
HXDLIN(  35)		Float m112 = this->rawData->__get((int)1);
HXDLIN(  35)		Float m122 = this->rawData->__get((int)5);
HXDLIN(  35)		Float m132 = this->rawData->__get((int)9);
HXDLIN(  35)		Float m142 = this->rawData->__get((int)13);
HXDLIN(  35)		Float m113 = this->rawData->__get((int)2);
HXDLIN(  35)		Float m123 = this->rawData->__get((int)6);
HXDLIN(  35)		Float m133 = this->rawData->__get((int)10);
HXDLIN(  35)		Float m143 = this->rawData->__get((int)14);
HXDLIN(  35)		Float m114 = this->rawData->__get((int)3);
HXDLIN(  35)		Float m124 = this->rawData->__get((int)7);
HXDLIN(  35)		Float m134 = this->rawData->__get((int)11);
HXDLIN(  35)		Float m144 = this->rawData->__get((int)15);
HXDLIN(  35)		Float m211 = lhs->rawData->__get((int)0);
HXDLIN(  35)		Float m221 = lhs->rawData->__get((int)4);
HXDLIN(  35)		Float m231 = lhs->rawData->__get((int)8);
HXDLIN(  35)		Float m241 = lhs->rawData->__get((int)12);
HXDLIN(  35)		Float m212 = lhs->rawData->__get((int)1);
HXDLIN(  35)		Float m222 = lhs->rawData->__get((int)5);
HXDLIN(  35)		Float m232 = lhs->rawData->__get((int)9);
HXDLIN(  35)		Float m242 = lhs->rawData->__get((int)13);
HXDLIN(  35)		Float m213 = lhs->rawData->__get((int)2);
HXDLIN(  35)		Float m223 = lhs->rawData->__get((int)6);
HXDLIN(  35)		Float m233 = lhs->rawData->__get((int)10);
HXDLIN(  35)		Float m243 = lhs->rawData->__get((int)14);
HXDLIN(  35)		Float m214 = lhs->rawData->__get((int)3);
HXDLIN(  35)		Float m224 = lhs->rawData->__get((int)7);
HXDLIN(  35)		Float m234 = lhs->rawData->__get((int)11);
HXDLIN(  35)		Float m244 = lhs->rawData->__get((int)15);
HXLINE(  44)		this->rawData[(int)0] = ((((m111 * m211) + (m112 * m221)) + (m113 * m231)) + (m114 * m241));
HXLINE(  45)		this->rawData[(int)1] = ((((m111 * m212) + (m112 * m222)) + (m113 * m232)) + (m114 * m242));
HXLINE(  46)		this->rawData[(int)2] = ((((m111 * m213) + (m112 * m223)) + (m113 * m233)) + (m114 * m243));
HXLINE(  47)		this->rawData[(int)3] = ((((m111 * m214) + (m112 * m224)) + (m113 * m234)) + (m114 * m244));
HXLINE(  49)		this->rawData[(int)4] = ((((m121 * m211) + (m122 * m221)) + (m123 * m231)) + (m124 * m241));
HXLINE(  50)		this->rawData[(int)5] = ((((m121 * m212) + (m122 * m222)) + (m123 * m232)) + (m124 * m242));
HXLINE(  51)		this->rawData[(int)6] = ((((m121 * m213) + (m122 * m223)) + (m123 * m233)) + (m124 * m243));
HXLINE(  52)		this->rawData[(int)7] = ((((m121 * m214) + (m122 * m224)) + (m123 * m234)) + (m124 * m244));
HXLINE(  54)		this->rawData[(int)8] = ((((m131 * m211) + (m132 * m221)) + (m133 * m231)) + (m134 * m241));
HXLINE(  55)		this->rawData[(int)9] = ((((m131 * m212) + (m132 * m222)) + (m133 * m232)) + (m134 * m242));
HXLINE(  56)		this->rawData[(int)10] = ((((m131 * m213) + (m132 * m223)) + (m133 * m233)) + (m134 * m243));
HXLINE(  57)		this->rawData[(int)11] = ((((m131 * m214) + (m132 * m224)) + (m133 * m234)) + (m134 * m244));
HXLINE(  59)		this->rawData[(int)12] = ((((m141 * m211) + (m142 * m221)) + (m143 * m231)) + (m144 * m241));
HXLINE(  60)		this->rawData[(int)13] = ((((m141 * m212) + (m142 * m222)) + (m143 * m232)) + (m144 * m242));
HXLINE(  61)		this->rawData[(int)14] = ((((m141 * m213) + (m142 * m223)) + (m143 * m233)) + (m144 * m243));
HXLINE(  62)		this->rawData[(int)15] = ((((m141 * m214) + (m142 * m224)) + (m143 * m234)) + (m144 * m244));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Matrix3D_obj,append,(void))

void Matrix3D_obj::appendRotation(Float degrees, ::openfl::geom::Vector3D axis, ::openfl::geom::Vector3D pivotPoint){
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_67_appendRotation)
HXLINE(  69)		 ::openfl::geom::Matrix3D m = ::openfl::geom::Matrix3D_obj::_hx___getAxisRotation(axis->x,axis->y,axis->z,degrees);
HXLINE(  71)		if (hx::IsNotNull( pivotPoint )) {
HXLINE(  73)			 ::openfl::geom::Vector3D p = pivotPoint;
HXLINE(  74)			m->appendTranslation(p->x,p->y,p->z);
            		}
HXLINE(  78)		this->append(m);
            	}


HX_DEFINE_DYNAMIC_FUNC3(Matrix3D_obj,appendRotation,(void))

void Matrix3D_obj::appendScale(Float xScale,Float yScale,Float zScale){
            	HX_GC_STACKFRAME(&_hx_pos_48294970c42d50e6_85_appendScale)
HXDLIN(  85)		this->append( ::openfl::geom::Matrix3D_obj::__alloc( HX_CTX ,::Array_obj< Float >::__new(16)->init(0,xScale)->init(1,((Float)0.0))->init(2,((Float)0.0))->init(3,((Float)0.0))->init(4,((Float)0.0))->init(5,yScale)->init(6,((Float)0.0))->init(7,((Float)0.0))->init(8,((Float)0.0))->init(9,((Float)0.0))->init(10,zScale)->init(11,((Float)0.0))->init(12,((Float)0.0))->init(13,((Float)0.0))->init(14,((Float)0.0))->init(15,((Float)1.0))));
            	}


HX_DEFINE_DYNAMIC_FUNC3(Matrix3D_obj,appendScale,(void))

void Matrix3D_obj::appendTranslation(Float x,Float y,Float z){
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_90_appendTranslation)
HXLINE(  92)		{
HXLINE(  92)			::Array< Float > _g = this->rawData;
HXDLIN(  92)			_g[(int)12] = (_g->__get((int)12) + x);
            		}
HXLINE(  93)		{
HXLINE(  93)			::Array< Float > _g1 = this->rawData;
HXDLIN(  93)			_g1[(int)13] = (_g1->__get((int)13) + y);
            		}
HXLINE(  94)		{
HXLINE(  94)			::Array< Float > _g2 = this->rawData;
HXDLIN(  94)			_g2[(int)14] = (_g2->__get((int)14) + z);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(Matrix3D_obj,appendTranslation,(void))

 ::openfl::geom::Matrix3D Matrix3D_obj::clone(){
            	HX_GC_STACKFRAME(&_hx_pos_48294970c42d50e6_101_clone)
HXDLIN( 101)		return  ::openfl::geom::Matrix3D_obj::__alloc( HX_CTX ,this->rawData->copy());
            	}


HX_DEFINE_DYNAMIC_FUNC0(Matrix3D_obj,clone,return )

void Matrix3D_obj::copyColumnFrom(int column, ::openfl::geom::Vector3D vector3D){
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_108_copyColumnFrom)
HXDLIN( 108)		switch((int)(column)){
            			case (int)0: {
HXLINE( 112)				this->rawData[(int)0] = vector3D->x;
HXLINE( 113)				this->rawData[(int)1] = vector3D->y;
HXLINE( 114)				this->rawData[(int)2] = vector3D->z;
HXLINE( 115)				this->rawData[(int)3] = vector3D->w;
            			}
            			break;
            			case (int)1: {
HXLINE( 119)				this->rawData[(int)4] = vector3D->x;
HXLINE( 120)				this->rawData[(int)5] = vector3D->y;
HXLINE( 121)				this->rawData[(int)6] = vector3D->z;
HXLINE( 122)				this->rawData[(int)7] = vector3D->w;
            			}
            			break;
            			case (int)2: {
HXLINE( 126)				this->rawData[(int)8] = vector3D->x;
HXLINE( 127)				this->rawData[(int)9] = vector3D->y;
HXLINE( 128)				this->rawData[(int)10] = vector3D->z;
HXLINE( 129)				this->rawData[(int)11] = vector3D->w;
            			}
            			break;
            			case (int)3: {
HXLINE( 133)				this->rawData[(int)12] = vector3D->x;
HXLINE( 134)				this->rawData[(int)13] = vector3D->y;
HXLINE( 135)				this->rawData[(int)14] = vector3D->z;
HXLINE( 136)				this->rawData[(int)15] = vector3D->w;
            			}
            			break;
            			default:{
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Matrix3D_obj,copyColumnFrom,(void))

void Matrix3D_obj::copyColumnTo(int column, ::openfl::geom::Vector3D vector3D){
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_147_copyColumnTo)
HXDLIN( 147)		switch((int)(column)){
            			case (int)0: {
HXLINE( 151)				vector3D->x = this->rawData->__get((int)0);
HXLINE( 152)				vector3D->y = this->rawData->__get((int)1);
HXLINE( 153)				vector3D->z = this->rawData->__get((int)2);
HXLINE( 154)				vector3D->w = this->rawData->__get((int)3);
            			}
            			break;
            			case (int)1: {
HXLINE( 158)				vector3D->x = this->rawData->__get((int)4);
HXLINE( 159)				vector3D->y = this->rawData->__get((int)5);
HXLINE( 160)				vector3D->z = this->rawData->__get((int)6);
HXLINE( 161)				vector3D->w = this->rawData->__get((int)7);
            			}
            			break;
            			case (int)2: {
HXLINE( 165)				vector3D->x = this->rawData->__get((int)8);
HXLINE( 166)				vector3D->y = this->rawData->__get((int)9);
HXLINE( 167)				vector3D->z = this->rawData->__get((int)10);
HXLINE( 168)				vector3D->w = this->rawData->__get((int)11);
            			}
            			break;
            			case (int)3: {
HXLINE( 172)				vector3D->x = this->rawData->__get((int)12);
HXLINE( 173)				vector3D->y = this->rawData->__get((int)13);
HXLINE( 174)				vector3D->z = this->rawData->__get((int)14);
HXLINE( 175)				vector3D->w = this->rawData->__get((int)15);
            			}
            			break;
            			default:{
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Matrix3D_obj,copyColumnTo,(void))

void Matrix3D_obj::copyFrom( ::openfl::geom::Matrix3D other){
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_186_copyFrom)
HXDLIN( 186)		this->rawData = other->rawData->copy();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Matrix3D_obj,copyFrom,(void))

void Matrix3D_obj::copyRawDataFrom(::Array< Float > vector,hx::Null< int >  __o_index,hx::Null< bool >  __o_transpose){
int index = __o_index.Default(0);
bool transpose = __o_transpose.Default(false);
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_191_copyRawDataFrom)
HXLINE( 193)		if (transpose) {
HXLINE( 195)			this->transpose();
            		}
HXLINE( 199)		int length = (vector->length - index);
HXLINE( 201)		{
HXLINE( 201)			int _g1 = (int)0;
HXDLIN( 201)			int _g = length;
HXDLIN( 201)			while((_g1 < _g)){
HXLINE( 201)				_g1 = (_g1 + (int)1);
HXDLIN( 201)				int i = (_g1 - (int)1);
HXLINE( 203)				this->rawData[i] = vector->__get((i + index));
            			}
            		}
HXLINE( 207)		if (transpose) {
HXLINE( 209)			this->transpose();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(Matrix3D_obj,copyRawDataFrom,(void))

void Matrix3D_obj::copyRawDataTo(::Array< Float > vector,hx::Null< int >  __o_index,hx::Null< bool >  __o_transpose){
int index = __o_index.Default(0);
bool transpose = __o_transpose.Default(false);
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_216_copyRawDataTo)
HXLINE( 218)		if (transpose) {
HXLINE( 220)			this->transpose();
            		}
HXLINE( 224)		{
HXLINE( 224)			int _g1 = (int)0;
HXDLIN( 224)			int _g = this->rawData->length;
HXDLIN( 224)			while((_g1 < _g)){
HXLINE( 224)				_g1 = (_g1 + (int)1);
HXDLIN( 224)				int i = (_g1 - (int)1);
HXLINE( 226)				vector[(i + index)] = this->rawData->__get(i);
            			}
            		}
HXLINE( 230)		if (transpose) {
HXLINE( 232)			this->transpose();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(Matrix3D_obj,copyRawDataTo,(void))

void Matrix3D_obj::copyRowFrom(int row, ::openfl::geom::Vector3D vector3D){
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_241_copyRowFrom)
HXDLIN( 241)		switch((int)(row)){
            			case (int)0: {
HXLINE( 245)				this->rawData[(int)0] = vector3D->x;
HXLINE( 246)				this->rawData[(int)4] = vector3D->y;
HXLINE( 247)				this->rawData[(int)8] = vector3D->z;
HXLINE( 248)				this->rawData[(int)12] = vector3D->w;
            			}
            			break;
            			case (int)1: {
HXLINE( 252)				this->rawData[(int)1] = vector3D->x;
HXLINE( 253)				this->rawData[(int)5] = vector3D->y;
HXLINE( 254)				this->rawData[(int)9] = vector3D->z;
HXLINE( 255)				this->rawData[(int)13] = vector3D->w;
            			}
            			break;
            			case (int)2: {
HXLINE( 259)				this->rawData[(int)2] = vector3D->x;
HXLINE( 260)				this->rawData[(int)6] = vector3D->y;
HXLINE( 261)				this->rawData[(int)10] = vector3D->z;
HXLINE( 262)				this->rawData[(int)14] = vector3D->w;
            			}
            			break;
            			case (int)3: {
HXLINE( 266)				this->rawData[(int)3] = vector3D->x;
HXLINE( 267)				this->rawData[(int)7] = vector3D->y;
HXLINE( 268)				this->rawData[(int)11] = vector3D->z;
HXLINE( 269)				this->rawData[(int)15] = vector3D->w;
            			}
            			break;
            			default:{
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Matrix3D_obj,copyRowFrom,(void))

void Matrix3D_obj::copyRowTo(int row, ::openfl::geom::Vector3D vector3D){
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_280_copyRowTo)
HXDLIN( 280)		switch((int)(row)){
            			case (int)0: {
HXLINE( 284)				vector3D->x = this->rawData->__get((int)0);
HXLINE( 285)				vector3D->y = this->rawData->__get((int)4);
HXLINE( 286)				vector3D->z = this->rawData->__get((int)8);
HXLINE( 287)				vector3D->w = this->rawData->__get((int)12);
            			}
            			break;
            			case (int)1: {
HXLINE( 291)				vector3D->x = this->rawData->__get((int)1);
HXLINE( 292)				vector3D->y = this->rawData->__get((int)5);
HXLINE( 293)				vector3D->z = this->rawData->__get((int)9);
HXLINE( 294)				vector3D->w = this->rawData->__get((int)13);
            			}
            			break;
            			case (int)2: {
HXLINE( 298)				vector3D->x = this->rawData->__get((int)2);
HXLINE( 299)				vector3D->y = this->rawData->__get((int)6);
HXLINE( 300)				vector3D->z = this->rawData->__get((int)10);
HXLINE( 301)				vector3D->w = this->rawData->__get((int)14);
            			}
            			break;
            			case (int)3: {
HXLINE( 305)				vector3D->x = this->rawData->__get((int)3);
HXLINE( 306)				vector3D->y = this->rawData->__get((int)7);
HXLINE( 307)				vector3D->z = this->rawData->__get((int)11);
HXLINE( 308)				vector3D->w = this->rawData->__get((int)15);
            			}
            			break;
            			default:{
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Matrix3D_obj,copyRowTo,(void))

void Matrix3D_obj::copyToMatrix3D( ::openfl::geom::Matrix3D other){
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_319_copyToMatrix3D)
HXDLIN( 319)		other->rawData = this->rawData->copy();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Matrix3D_obj,copyToMatrix3D,(void))

::Array< ::Dynamic> Matrix3D_obj::decompose( ::Dynamic orientationStyle){
            	HX_GC_STACKFRAME(&_hx_pos_48294970c42d50e6_353_decompose)
HXLINE( 355)		if (hx::IsNull( orientationStyle )) {
HXLINE( 357)			orientationStyle = (int)1;
            		}
HXLINE( 361)		::Array< ::Dynamic> this1 = ::Array_obj< ::Dynamic>::__new();
HXDLIN( 361)		this1->__SetSizeExact(null());
HXDLIN( 361)		::Array< ::Dynamic> vec = this1;
HXLINE( 362)		 ::openfl::geom::Matrix3D m = this->clone();
HXLINE( 363)		::Array< Float > mr = m->rawData->copy();
HXLINE( 365)		 ::openfl::geom::Vector3D pos =  ::openfl::geom::Vector3D_obj::__alloc( HX_CTX ,mr->__get((int)12),mr->__get((int)13),mr->__get((int)14),null());
HXLINE( 366)		mr[(int)12] = (int)0;
HXLINE( 367)		mr[(int)13] = (int)0;
HXLINE( 368)		mr[(int)14] = (int)0;
HXLINE( 370)		 ::openfl::geom::Vector3D scale =  ::openfl::geom::Vector3D_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE( 372)		scale->x = ::Math_obj::sqrt((((mr->__get((int)0) * mr->__get((int)0)) + (mr->__get((int)1) * mr->__get((int)1))) + (mr->__get((int)2) * mr->__get((int)2))));
HXLINE( 373)		scale->y = ::Math_obj::sqrt((((mr->__get((int)4) * mr->__get((int)4)) + (mr->__get((int)5) * mr->__get((int)5))) + (mr->__get((int)6) * mr->__get((int)6))));
HXLINE( 374)		scale->z = ::Math_obj::sqrt((((mr->__get((int)8) * mr->__get((int)8)) + (mr->__get((int)9) * mr->__get((int)9))) + (mr->__get((int)10) * mr->__get((int)10))));
HXLINE( 376)		if (((((mr->__get((int)0) * ((mr->__get((int)5) * mr->__get((int)10)) - (mr->__get((int)6) * mr->__get((int)9)))) - (mr->__get((int)1) * ((mr->__get((int)4) * mr->__get((int)10)) - (mr->__get((int)6) * mr->__get((int)8))))) + (mr->__get((int)2) * ((mr->__get((int)4) * mr->__get((int)9)) - (mr->__get((int)5) * mr->__get((int)8))))) < (int)0)) {
HXLINE( 378)			scale->z = -(scale->z);
            		}
HXLINE( 382)		{
HXLINE( 382)			::Array< Float > _g = mr;
HXDLIN( 382)			_g[(int)0] = ((Float)_g->__get((int)0) / (Float)scale->x);
            		}
HXLINE( 383)		{
HXLINE( 383)			::Array< Float > _g1 = mr;
HXDLIN( 383)			_g1[(int)1] = ((Float)_g1->__get((int)1) / (Float)scale->x);
            		}
HXLINE( 384)		{
HXLINE( 384)			::Array< Float > _g2 = mr;
HXDLIN( 384)			_g2[(int)2] = ((Float)_g2->__get((int)2) / (Float)scale->x);
            		}
HXLINE( 385)		{
HXLINE( 385)			::Array< Float > _g3 = mr;
HXDLIN( 385)			_g3[(int)4] = ((Float)_g3->__get((int)4) / (Float)scale->y);
            		}
HXLINE( 386)		{
HXLINE( 386)			::Array< Float > _g4 = mr;
HXDLIN( 386)			_g4[(int)5] = ((Float)_g4->__get((int)5) / (Float)scale->y);
            		}
HXLINE( 387)		{
HXLINE( 387)			::Array< Float > _g5 = mr;
HXDLIN( 387)			_g5[(int)6] = ((Float)_g5->__get((int)6) / (Float)scale->y);
            		}
HXLINE( 388)		{
HXLINE( 388)			::Array< Float > _g6 = mr;
HXDLIN( 388)			_g6[(int)8] = ((Float)_g6->__get((int)8) / (Float)scale->z);
            		}
HXLINE( 389)		{
HXLINE( 389)			::Array< Float > _g7 = mr;
HXDLIN( 389)			_g7[(int)9] = ((Float)_g7->__get((int)9) / (Float)scale->z);
            		}
HXLINE( 390)		{
HXLINE( 390)			::Array< Float > _g8 = mr;
HXDLIN( 390)			_g8[(int)10] = ((Float)_g8->__get((int)10) / (Float)scale->z);
            		}
HXLINE( 392)		 ::openfl::geom::Vector3D rot =  ::openfl::geom::Vector3D_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE( 394)		 ::Dynamic _hx_switch_0 = orientationStyle;
            		if (  (_hx_switch_0==(int)0) ){
HXLINE( 398)			rot->w = ::Math_obj::acos(((Float)(((mr->__get((int)0) + mr->__get((int)5)) + mr->__get((int)10)) - (int)1) / (Float)(int)2));
HXLINE( 400)			Float len = ::Math_obj::sqrt(((((mr->__get((int)6) - mr->__get((int)9)) * (mr->__get((int)6) - mr->__get((int)9))) + ((mr->__get((int)8) - mr->__get((int)2)) * (mr->__get((int)8) - mr->__get((int)2)))) + ((mr->__get((int)1) - mr->__get((int)4)) * (mr->__get((int)1) - mr->__get((int)4)))));
HXLINE( 402)			if ((len != (int)0)) {
HXLINE( 404)				rot->x = ((Float)(mr->__get((int)6) - mr->__get((int)9)) / (Float)len);
HXLINE( 405)				rot->y = ((Float)(mr->__get((int)8) - mr->__get((int)2)) / (Float)len);
HXLINE( 406)				rot->z = ((Float)(mr->__get((int)1) - mr->__get((int)4)) / (Float)len);
            			}
            			else {
HXLINE( 410)				rot->x = (rot->y = (rot->z = (int)0));
            			}
HXLINE( 396)			goto _hx_goto_17;
            		}
            		if (  (_hx_switch_0==(int)1) ){
HXLINE( 454)			rot->y = ::Math_obj::asin(-(mr->__get((int)2)));
HXLINE( 456)			bool _hx_tmp;
HXDLIN( 456)			if ((mr->__get((int)2) != (int)1)) {
HXLINE( 456)				_hx_tmp = (mr->__get((int)2) != (int)-1);
            			}
            			else {
HXLINE( 456)				_hx_tmp = false;
            			}
HXDLIN( 456)			if (_hx_tmp) {
HXLINE( 458)				rot->x = ::Math_obj::atan2(mr->__get((int)6),mr->__get((int)10));
HXLINE( 459)				rot->z = ::Math_obj::atan2(mr->__get((int)1),mr->__get((int)0));
            			}
            			else {
HXLINE( 463)				rot->z = (int)0;
HXLINE( 464)				rot->x = ::Math_obj::atan2(mr->__get((int)4),mr->__get((int)5));
            			}
HXLINE( 452)			goto _hx_goto_17;
            		}
            		if (  (_hx_switch_0==(int)2) ){
HXLINE( 416)			Float tr = ((mr->__get((int)0) + mr->__get((int)5)) + mr->__get((int)10));
HXLINE( 418)			if ((tr > (int)0)) {
HXLINE( 420)				rot->w = ((Float)::Math_obj::sqrt(((int)1 + tr)) / (Float)(int)2);
HXLINE( 422)				rot->x = ((Float)(mr->__get((int)6) - mr->__get((int)9)) / (Float)((int)4 * rot->w));
HXLINE( 423)				rot->y = ((Float)(mr->__get((int)8) - mr->__get((int)2)) / (Float)((int)4 * rot->w));
HXLINE( 424)				rot->z = ((Float)(mr->__get((int)1) - mr->__get((int)4)) / (Float)((int)4 * rot->w));
            			}
            			else {
HXLINE( 426)				bool _hx_tmp1;
HXDLIN( 426)				if ((mr->__get((int)0) > mr->__get((int)5))) {
HXLINE( 426)					_hx_tmp1 = (mr->__get((int)0) > mr->__get((int)10));
            				}
            				else {
HXLINE( 426)					_hx_tmp1 = false;
            				}
HXDLIN( 426)				if (_hx_tmp1) {
HXLINE( 428)					rot->x = ((Float)::Math_obj::sqrt(((((int)1 + mr->__get((int)0)) - mr->__get((int)5)) - mr->__get((int)10))) / (Float)(int)2);
HXLINE( 430)					rot->w = ((Float)(mr->__get((int)6) - mr->__get((int)9)) / (Float)((int)4 * rot->x));
HXLINE( 431)					rot->y = ((Float)(mr->__get((int)1) + mr->__get((int)4)) / (Float)((int)4 * rot->x));
HXLINE( 432)					rot->z = ((Float)(mr->__get((int)8) + mr->__get((int)2)) / (Float)((int)4 * rot->x));
            				}
            				else {
HXLINE( 434)					if ((mr->__get((int)5) > mr->__get((int)10))) {
HXLINE( 436)						rot->y = ((Float)::Math_obj::sqrt(((((int)1 + mr->__get((int)5)) - mr->__get((int)0)) - mr->__get((int)10))) / (Float)(int)2);
HXLINE( 438)						rot->x = ((Float)(mr->__get((int)1) + mr->__get((int)4)) / (Float)((int)4 * rot->y));
HXLINE( 439)						rot->w = ((Float)(mr->__get((int)8) - mr->__get((int)2)) / (Float)((int)4 * rot->y));
HXLINE( 440)						rot->z = ((Float)(mr->__get((int)6) + mr->__get((int)9)) / (Float)((int)4 * rot->y));
            					}
            					else {
HXLINE( 444)						rot->z = ((Float)::Math_obj::sqrt(((((int)1 + mr->__get((int)10)) - mr->__get((int)0)) - mr->__get((int)5))) / (Float)(int)2);
HXLINE( 446)						rot->x = ((Float)(mr->__get((int)8) + mr->__get((int)2)) / (Float)((int)4 * rot->z));
HXLINE( 447)						rot->y = ((Float)(mr->__get((int)6) + mr->__get((int)9)) / (Float)((int)4 * rot->z));
HXLINE( 448)						rot->w = ((Float)(mr->__get((int)1) - mr->__get((int)4)) / (Float)((int)4 * rot->z));
            					}
            				}
            			}
HXLINE( 414)			goto _hx_goto_17;
            		}
            		_hx_goto_17:;
HXLINE( 470)		vec->push(pos);
HXLINE( 471)		vec->push(rot);
HXLINE( 472)		vec->push(scale);
HXLINE( 474)		return vec;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Matrix3D_obj,decompose,return )

 ::openfl::geom::Vector3D Matrix3D_obj::deltaTransformVector( ::openfl::geom::Vector3D v){
            	HX_GC_STACKFRAME(&_hx_pos_48294970c42d50e6_479_deltaTransformVector)
HXLINE( 481)		Float x = v->x;
HXDLIN( 481)		Float y = v->y;
HXDLIN( 481)		Float z = v->z;
HXLINE( 483)		Float _hx_tmp = (x * this->rawData->__get((int)0));
HXDLIN( 483)		Float _hx_tmp1 = (_hx_tmp + (y * this->rawData->__get((int)4)));
HXDLIN( 483)		Float _hx_tmp2 = ((_hx_tmp1 + (z * this->rawData->__get((int)8))) + this->rawData->__get((int)3));
HXDLIN( 483)		Float _hx_tmp3 = (x * this->rawData->__get((int)1));
HXDLIN( 483)		Float _hx_tmp4 = (_hx_tmp3 + (y * this->rawData->__get((int)5)));
HXDLIN( 483)		Float _hx_tmp5 = ((_hx_tmp4 + (z * this->rawData->__get((int)9))) + this->rawData->__get((int)7));
HXDLIN( 483)		Float _hx_tmp6 = (x * this->rawData->__get((int)2));
HXDLIN( 483)		Float _hx_tmp7 = (_hx_tmp6 + (y * this->rawData->__get((int)6)));
HXDLIN( 483)		return  ::openfl::geom::Vector3D_obj::__alloc( HX_CTX ,_hx_tmp2,_hx_tmp5,((_hx_tmp7 + (z * this->rawData->__get((int)10))) + this->rawData->__get((int)11)),(int)0);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Matrix3D_obj,deltaTransformVector,return )

void Matrix3D_obj::identity(){
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_490_identity)
HXDLIN( 490)		this->rawData = ::Array_obj< Float >::fromData( _hx_array_data_3d2e93e6_21,16);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Matrix3D_obj,identity,(void))

void Matrix3D_obj::interpolateTo( ::openfl::geom::Matrix3D toMat,Float percent){
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_512_interpolateTo)
HXDLIN( 512)		int _g = (int)0;
HXDLIN( 512)		while((_g < (int)16)){
HXDLIN( 512)			_g = (_g + (int)1);
HXDLIN( 512)			int i = (_g - (int)1);
HXLINE( 514)			{
HXLINE( 514)				 ::Dynamic value = this->rawData->__get(i);
HXDLIN( 514)				this->rawData[i] = (value + ((toMat->rawData->__get(i) - this->rawData->__get(i)) * percent));
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Matrix3D_obj,interpolateTo,(void))

bool Matrix3D_obj::invert(){
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_521_invert)
HXLINE( 523)		Float d = this->get_determinant();
HXLINE( 524)		bool invertable = (::Math_obj::abs(d) > ((Float)0.00000000001));
HXLINE( 526)		if (invertable) {
HXLINE( 528)			d = ((Float)(int)1 / (Float)d);
HXLINE( 530)			Float m11 = this->rawData->__get((int)0);
HXDLIN( 530)			Float m21 = this->rawData->__get((int)4);
HXDLIN( 530)			Float m31 = this->rawData->__get((int)8);
HXDLIN( 530)			Float m41 = this->rawData->__get((int)12);
HXLINE( 531)			Float m12 = this->rawData->__get((int)1);
HXDLIN( 531)			Float m22 = this->rawData->__get((int)5);
HXDLIN( 531)			Float m32 = this->rawData->__get((int)9);
HXDLIN( 531)			Float m42 = this->rawData->__get((int)13);
HXLINE( 532)			Float m13 = this->rawData->__get((int)2);
HXDLIN( 532)			Float m23 = this->rawData->__get((int)6);
HXDLIN( 532)			Float m33 = this->rawData->__get((int)10);
HXDLIN( 532)			Float m43 = this->rawData->__get((int)14);
HXLINE( 533)			Float m14 = this->rawData->__get((int)3);
HXDLIN( 533)			Float m24 = this->rawData->__get((int)7);
HXDLIN( 533)			Float m34 = this->rawData->__get((int)11);
HXDLIN( 533)			Float m44 = this->rawData->__get((int)15);
HXLINE( 535)			this->rawData[(int)0] = (d * (((m22 * ((m33 * m44) - (m43 * m34))) - (m32 * ((m23 * m44) - (m43 * m24)))) + (m42 * ((m23 * m34) - (m33 * m24)))));
HXLINE( 536)			this->rawData[(int)1] = (-(d) * (((m12 * ((m33 * m44) - (m43 * m34))) - (m32 * ((m13 * m44) - (m43 * m14)))) + (m42 * ((m13 * m34) - (m33 * m14)))));
HXLINE( 537)			this->rawData[(int)2] = (d * (((m12 * ((m23 * m44) - (m43 * m24))) - (m22 * ((m13 * m44) - (m43 * m14)))) + (m42 * ((m13 * m24) - (m23 * m14)))));
HXLINE( 538)			this->rawData[(int)3] = (-(d) * (((m12 * ((m23 * m34) - (m33 * m24))) - (m22 * ((m13 * m34) - (m33 * m14)))) + (m32 * ((m13 * m24) - (m23 * m14)))));
HXLINE( 539)			this->rawData[(int)4] = (-(d) * (((m21 * ((m33 * m44) - (m43 * m34))) - (m31 * ((m23 * m44) - (m43 * m24)))) + (m41 * ((m23 * m34) - (m33 * m24)))));
HXLINE( 540)			this->rawData[(int)5] = (d * (((m11 * ((m33 * m44) - (m43 * m34))) - (m31 * ((m13 * m44) - (m43 * m14)))) + (m41 * ((m13 * m34) - (m33 * m14)))));
HXLINE( 541)			this->rawData[(int)6] = (-(d) * (((m11 * ((m23 * m44) - (m43 * m24))) - (m21 * ((m13 * m44) - (m43 * m14)))) + (m41 * ((m13 * m24) - (m23 * m14)))));
HXLINE( 542)			this->rawData[(int)7] = (d * (((m11 * ((m23 * m34) - (m33 * m24))) - (m21 * ((m13 * m34) - (m33 * m14)))) + (m31 * ((m13 * m24) - (m23 * m14)))));
HXLINE( 543)			this->rawData[(int)8] = (d * (((m21 * ((m32 * m44) - (m42 * m34))) - (m31 * ((m22 * m44) - (m42 * m24)))) + (m41 * ((m22 * m34) - (m32 * m24)))));
HXLINE( 544)			this->rawData[(int)9] = (-(d) * (((m11 * ((m32 * m44) - (m42 * m34))) - (m31 * ((m12 * m44) - (m42 * m14)))) + (m41 * ((m12 * m34) - (m32 * m14)))));
HXLINE( 545)			this->rawData[(int)10] = (d * (((m11 * ((m22 * m44) - (m42 * m24))) - (m21 * ((m12 * m44) - (m42 * m14)))) + (m41 * ((m12 * m24) - (m22 * m14)))));
HXLINE( 546)			this->rawData[(int)11] = (-(d) * (((m11 * ((m22 * m34) - (m32 * m24))) - (m21 * ((m12 * m34) - (m32 * m14)))) + (m31 * ((m12 * m24) - (m22 * m14)))));
HXLINE( 547)			this->rawData[(int)12] = (-(d) * (((m21 * ((m32 * m43) - (m42 * m33))) - (m31 * ((m22 * m43) - (m42 * m23)))) + (m41 * ((m22 * m33) - (m32 * m23)))));
HXLINE( 548)			this->rawData[(int)13] = (d * (((m11 * ((m32 * m43) - (m42 * m33))) - (m31 * ((m12 * m43) - (m42 * m13)))) + (m41 * ((m12 * m33) - (m32 * m13)))));
HXLINE( 549)			this->rawData[(int)14] = (-(d) * (((m11 * ((m22 * m43) - (m42 * m23))) - (m21 * ((m12 * m43) - (m42 * m13)))) + (m41 * ((m12 * m23) - (m22 * m13)))));
HXLINE( 550)			this->rawData[(int)15] = (d * (((m11 * ((m22 * m33) - (m32 * m23))) - (m21 * ((m12 * m33) - (m32 * m13)))) + (m31 * ((m12 * m23) - (m22 * m13)))));
            		}
HXLINE( 554)		return invertable;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Matrix3D_obj,invert,return )

void Matrix3D_obj::pointAt( ::openfl::geom::Vector3D pos, ::openfl::geom::Vector3D at, ::openfl::geom::Vector3D up){
            	HX_GC_STACKFRAME(&_hx_pos_48294970c42d50e6_559_pointAt)
HXLINE( 561)		if (hx::IsNull( at )) {
HXLINE( 563)			at =  ::openfl::geom::Vector3D_obj::__alloc( HX_CTX ,(int)0,(int)0,(int)-1,null());
            		}
HXLINE( 567)		if (hx::IsNull( up )) {
HXLINE( 569)			up =  ::openfl::geom::Vector3D_obj::__alloc( HX_CTX ,(int)0,(int)-1,(int)0,null());
            		}
HXLINE( 573)		 ::openfl::geom::Vector3D dir = at->subtract(pos);
HXLINE( 574)		 ::openfl::geom::Vector3D vup = up->clone();
HXLINE( 575)		 ::openfl::geom::Vector3D right;
HXLINE( 577)		dir->normalize();
HXLINE( 578)		vup->normalize();
HXLINE( 580)		 ::openfl::geom::Vector3D dir2 = dir->clone();
HXLINE( 581)		dir2->scaleBy(vup->dotProduct(dir));
HXLINE( 583)		vup = vup->subtract(dir2);
HXLINE( 585)		if ((vup->get_length() > (int)0)) {
HXLINE( 587)			vup->normalize();
            		}
            		else {
HXLINE( 591)			if ((dir->x != (int)0)) {
HXLINE( 593)				vup =  ::openfl::geom::Vector3D_obj::__alloc( HX_CTX ,-(dir->y),dir->x,(int)0,null());
            			}
            			else {
HXLINE( 597)				vup =  ::openfl::geom::Vector3D_obj::__alloc( HX_CTX ,(int)1,(int)0,(int)0,null());
            			}
            		}
HXLINE( 603)		right = vup->crossProduct(dir);
HXLINE( 604)		right->normalize();
HXLINE( 606)		this->rawData[(int)0] = right->x;
HXLINE( 607)		this->rawData[(int)4] = right->y;
HXLINE( 608)		this->rawData[(int)8] = right->z;
HXLINE( 609)		this->rawData[(int)12] = ((Float)0.0);
HXLINE( 610)		this->rawData[(int)1] = vup->x;
HXLINE( 611)		this->rawData[(int)5] = vup->y;
HXLINE( 612)		this->rawData[(int)9] = vup->z;
HXLINE( 613)		this->rawData[(int)13] = ((Float)0.0);
HXLINE( 614)		this->rawData[(int)2] = dir->x;
HXLINE( 615)		this->rawData[(int)6] = dir->y;
HXLINE( 616)		this->rawData[(int)10] = dir->z;
HXLINE( 617)		this->rawData[(int)14] = ((Float)0.0);
HXLINE( 618)		this->rawData[(int)3] = pos->x;
HXLINE( 619)		this->rawData[(int)7] = pos->y;
HXLINE( 620)		this->rawData[(int)11] = pos->z;
HXLINE( 621)		this->rawData[(int)15] = ((Float)1.0);
            	}


HX_DEFINE_DYNAMIC_FUNC3(Matrix3D_obj,pointAt,(void))

void Matrix3D_obj::prepend( ::openfl::geom::Matrix3D rhs){
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_626_prepend)
HXLINE( 628)		Float m111 = rhs->rawData->__get((int)0);
HXDLIN( 628)		Float m121 = rhs->rawData->__get((int)4);
HXDLIN( 628)		Float m131 = rhs->rawData->__get((int)8);
HXDLIN( 628)		Float m141 = rhs->rawData->__get((int)12);
HXDLIN( 628)		Float m112 = rhs->rawData->__get((int)1);
HXDLIN( 628)		Float m122 = rhs->rawData->__get((int)5);
HXDLIN( 628)		Float m132 = rhs->rawData->__get((int)9);
HXDLIN( 628)		Float m142 = rhs->rawData->__get((int)13);
HXDLIN( 628)		Float m113 = rhs->rawData->__get((int)2);
HXDLIN( 628)		Float m123 = rhs->rawData->__get((int)6);
HXDLIN( 628)		Float m133 = rhs->rawData->__get((int)10);
HXDLIN( 628)		Float m143 = rhs->rawData->__get((int)14);
HXDLIN( 628)		Float m114 = rhs->rawData->__get((int)3);
HXDLIN( 628)		Float m124 = rhs->rawData->__get((int)7);
HXDLIN( 628)		Float m134 = rhs->rawData->__get((int)11);
HXDLIN( 628)		Float m144 = rhs->rawData->__get((int)15);
HXDLIN( 628)		Float m211 = this->rawData->__get((int)0);
HXDLIN( 628)		Float m221 = this->rawData->__get((int)4);
HXDLIN( 628)		Float m231 = this->rawData->__get((int)8);
HXDLIN( 628)		Float m241 = this->rawData->__get((int)12);
HXDLIN( 628)		Float m212 = this->rawData->__get((int)1);
HXDLIN( 628)		Float m222 = this->rawData->__get((int)5);
HXDLIN( 628)		Float m232 = this->rawData->__get((int)9);
HXDLIN( 628)		Float m242 = this->rawData->__get((int)13);
HXDLIN( 628)		Float m213 = this->rawData->__get((int)2);
HXDLIN( 628)		Float m223 = this->rawData->__get((int)6);
HXDLIN( 628)		Float m233 = this->rawData->__get((int)10);
HXDLIN( 628)		Float m243 = this->rawData->__get((int)14);
HXDLIN( 628)		Float m214 = this->rawData->__get((int)3);
HXDLIN( 628)		Float m224 = this->rawData->__get((int)7);
HXDLIN( 628)		Float m234 = this->rawData->__get((int)11);
HXDLIN( 628)		Float m244 = this->rawData->__get((int)15);
HXLINE( 637)		this->rawData[(int)0] = ((((m111 * m211) + (m112 * m221)) + (m113 * m231)) + (m114 * m241));
HXLINE( 638)		this->rawData[(int)1] = ((((m111 * m212) + (m112 * m222)) + (m113 * m232)) + (m114 * m242));
HXLINE( 639)		this->rawData[(int)2] = ((((m111 * m213) + (m112 * m223)) + (m113 * m233)) + (m114 * m243));
HXLINE( 640)		this->rawData[(int)3] = ((((m111 * m214) + (m112 * m224)) + (m113 * m234)) + (m114 * m244));
HXLINE( 642)		this->rawData[(int)4] = ((((m121 * m211) + (m122 * m221)) + (m123 * m231)) + (m124 * m241));
HXLINE( 643)		this->rawData[(int)5] = ((((m121 * m212) + (m122 * m222)) + (m123 * m232)) + (m124 * m242));
HXLINE( 644)		this->rawData[(int)6] = ((((m121 * m213) + (m122 * m223)) + (m123 * m233)) + (m124 * m243));
HXLINE( 645)		this->rawData[(int)7] = ((((m121 * m214) + (m122 * m224)) + (m123 * m234)) + (m124 * m244));
HXLINE( 647)		this->rawData[(int)8] = ((((m131 * m211) + (m132 * m221)) + (m133 * m231)) + (m134 * m241));
HXLINE( 648)		this->rawData[(int)9] = ((((m131 * m212) + (m132 * m222)) + (m133 * m232)) + (m134 * m242));
HXLINE( 649)		this->rawData[(int)10] = ((((m131 * m213) + (m132 * m223)) + (m133 * m233)) + (m134 * m243));
HXLINE( 650)		this->rawData[(int)11] = ((((m131 * m214) + (m132 * m224)) + (m133 * m234)) + (m134 * m244));
HXLINE( 652)		this->rawData[(int)12] = ((((m141 * m211) + (m142 * m221)) + (m143 * m231)) + (m144 * m241));
HXLINE( 653)		this->rawData[(int)13] = ((((m141 * m212) + (m142 * m222)) + (m143 * m232)) + (m144 * m242));
HXLINE( 654)		this->rawData[(int)14] = ((((m141 * m213) + (m142 * m223)) + (m143 * m233)) + (m144 * m243));
HXLINE( 655)		this->rawData[(int)15] = ((((m141 * m214) + (m142 * m224)) + (m143 * m234)) + (m144 * m244));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Matrix3D_obj,prepend,(void))

void Matrix3D_obj::prependRotation(Float degrees, ::openfl::geom::Vector3D axis, ::openfl::geom::Vector3D pivotPoint){
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_660_prependRotation)
HXLINE( 662)		 ::openfl::geom::Matrix3D m = ::openfl::geom::Matrix3D_obj::_hx___getAxisRotation(axis->x,axis->y,axis->z,degrees);
HXLINE( 664)		if (hx::IsNotNull( pivotPoint )) {
HXLINE( 666)			 ::openfl::geom::Vector3D p = pivotPoint;
HXLINE( 667)			m->appendTranslation(p->x,p->y,p->z);
            		}
HXLINE( 671)		this->prepend(m);
            	}


HX_DEFINE_DYNAMIC_FUNC3(Matrix3D_obj,prependRotation,(void))

void Matrix3D_obj::prependScale(Float xScale,Float yScale,Float zScale){
            	HX_GC_STACKFRAME(&_hx_pos_48294970c42d50e6_678_prependScale)
HXDLIN( 678)		this->prepend( ::openfl::geom::Matrix3D_obj::__alloc( HX_CTX ,::Array_obj< Float >::__new(16)->init(0,xScale)->init(1,((Float)0.0))->init(2,((Float)0.0))->init(3,((Float)0.0))->init(4,((Float)0.0))->init(5,yScale)->init(6,((Float)0.0))->init(7,((Float)0.0))->init(8,((Float)0.0))->init(9,((Float)0.0))->init(10,zScale)->init(11,((Float)0.0))->init(12,((Float)0.0))->init(13,((Float)0.0))->init(14,((Float)0.0))->init(15,((Float)1.0))));
            	}


HX_DEFINE_DYNAMIC_FUNC3(Matrix3D_obj,prependScale,(void))

void Matrix3D_obj::prependTranslation(Float x,Float y,Float z){
            	HX_GC_STACKFRAME(&_hx_pos_48294970c42d50e6_683_prependTranslation)
HXLINE( 685)		 ::openfl::geom::Matrix3D m =  ::openfl::geom::Matrix3D_obj::__alloc( HX_CTX ,null());
HXLINE( 686)		m->set_position( ::openfl::geom::Vector3D_obj::__alloc( HX_CTX ,x,y,z,null()));
HXLINE( 687)		this->prepend(m);
            	}


HX_DEFINE_DYNAMIC_FUNC3(Matrix3D_obj,prependTranslation,(void))

bool Matrix3D_obj::recompose(::Array< ::Dynamic> components, ::Dynamic orientationStyle){
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_692_recompose)
HXLINE( 694)		bool _hx_tmp;
HXDLIN( 694)		bool _hx_tmp1;
HXDLIN( 694)		bool _hx_tmp2;
HXDLIN( 694)		if ((components->length >= (int)3)) {
HXLINE( 694)			_hx_tmp2 = (components->__get((int)2).StaticCast<  ::openfl::geom::Vector3D >()->x == (int)0);
            		}
            		else {
HXLINE( 694)			_hx_tmp2 = true;
            		}
HXDLIN( 694)		if (!(_hx_tmp2)) {
HXLINE( 694)			_hx_tmp1 = (components->__get((int)2).StaticCast<  ::openfl::geom::Vector3D >()->y == (int)0);
            		}
            		else {
HXLINE( 694)			_hx_tmp1 = true;
            		}
HXDLIN( 694)		if (!(_hx_tmp1)) {
HXLINE( 694)			_hx_tmp = (components->__get((int)2).StaticCast<  ::openfl::geom::Vector3D >()->z == (int)0);
            		}
            		else {
HXLINE( 694)			_hx_tmp = true;
            		}
HXDLIN( 694)		if (_hx_tmp) {
HXLINE( 696)			return false;
            		}
HXLINE( 700)		if (hx::IsNull( orientationStyle )) {
HXLINE( 702)			orientationStyle = (int)1;
            		}
HXLINE( 706)		this->identity();
HXLINE( 708)		::Array< Float > scale = ::Array_obj< Float >::__new(0);
HXLINE( 709)		scale[(int)0] = (scale[(int)1] = (scale[(int)2] = components->__get((int)2).StaticCast<  ::openfl::geom::Vector3D >()->x));
HXLINE( 710)		scale[(int)4] = (scale[(int)5] = (scale[(int)6] = components->__get((int)2).StaticCast<  ::openfl::geom::Vector3D >()->y));
HXLINE( 711)		scale[(int)8] = (scale[(int)9] = (scale[(int)10] = components->__get((int)2).StaticCast<  ::openfl::geom::Vector3D >()->z));
HXLINE( 713)		if (hx::IsNull( orientationStyle )) {
HXLINE( 743)			Float x = components->__get((int)1).StaticCast<  ::openfl::geom::Vector3D >()->x;
HXLINE( 744)			Float y = components->__get((int)1).StaticCast<  ::openfl::geom::Vector3D >()->y;
HXLINE( 745)			Float z = components->__get((int)1).StaticCast<  ::openfl::geom::Vector3D >()->z;
HXLINE( 746)			Float w = components->__get((int)1).StaticCast<  ::openfl::geom::Vector3D >()->w;
HXLINE( 748)			if (::Type_obj::enumEq(orientationStyle,(int)0)) {
HXLINE( 750)				x = (x * ::Math_obj::sin(((Float)w / (Float)(int)2)));
HXLINE( 751)				y = (y * ::Math_obj::sin(((Float)w / (Float)(int)2)));
HXLINE( 752)				z = (z * ::Math_obj::sin(((Float)w / (Float)(int)2)));
HXLINE( 753)				w = ::Math_obj::cos(((Float)w / (Float)(int)2));
            			}
HXLINE( 757)			this->rawData[(int)0] = ((((int)1 - (((int)2 * y) * y)) - (((int)2 * z) * z)) * scale->__get((int)0));
HXLINE( 758)			this->rawData[(int)1] = (((((int)2 * x) * y) + (((int)2 * w) * z)) * scale->__get((int)1));
HXLINE( 759)			this->rawData[(int)2] = (((((int)2 * x) * z) - (((int)2 * w) * y)) * scale->__get((int)2));
HXLINE( 760)			this->rawData[(int)3] = (int)0;
HXLINE( 761)			this->rawData[(int)4] = (((((int)2 * x) * y) - (((int)2 * w) * z)) * scale->__get((int)4));
HXLINE( 762)			this->rawData[(int)5] = ((((int)1 - (((int)2 * x) * x)) - (((int)2 * z) * z)) * scale->__get((int)5));
HXLINE( 763)			this->rawData[(int)6] = (((((int)2 * y) * z) + (((int)2 * w) * x)) * scale->__get((int)6));
HXLINE( 764)			this->rawData[(int)7] = (int)0;
HXLINE( 765)			this->rawData[(int)8] = (((((int)2 * x) * z) + (((int)2 * w) * y)) * scale->__get((int)8));
HXLINE( 766)			this->rawData[(int)9] = (((((int)2 * y) * z) - (((int)2 * w) * x)) * scale->__get((int)9));
HXLINE( 767)			this->rawData[(int)10] = ((((int)1 - (((int)2 * x) * x)) - (((int)2 * y) * y)) * scale->__get((int)10));
HXLINE( 768)			this->rawData[(int)11] = (int)0;
HXLINE( 769)			this->rawData[(int)12] = components->__get((int)0).StaticCast<  ::openfl::geom::Vector3D >()->x;
HXLINE( 770)			this->rawData[(int)13] = components->__get((int)0).StaticCast<  ::openfl::geom::Vector3D >()->y;
HXLINE( 771)			this->rawData[(int)14] = components->__get((int)0).StaticCast<  ::openfl::geom::Vector3D >()->z;
HXLINE( 772)			this->rawData[(int)15] = (int)1;
            		}
            		else {
HXLINE( 713)			if (hx::IsEq( orientationStyle,(int)1 )) {
HXLINE( 717)				Float cx = ::Math_obj::cos(components->__get((int)1).StaticCast<  ::openfl::geom::Vector3D >()->x);
HXLINE( 718)				Float cy = ::Math_obj::cos(components->__get((int)1).StaticCast<  ::openfl::geom::Vector3D >()->y);
HXLINE( 719)				Float cz = ::Math_obj::cos(components->__get((int)1).StaticCast<  ::openfl::geom::Vector3D >()->z);
HXLINE( 720)				Float sx = ::Math_obj::sin(components->__get((int)1).StaticCast<  ::openfl::geom::Vector3D >()->x);
HXLINE( 721)				Float sy = ::Math_obj::sin(components->__get((int)1).StaticCast<  ::openfl::geom::Vector3D >()->y);
HXLINE( 722)				Float sz = ::Math_obj::sin(components->__get((int)1).StaticCast<  ::openfl::geom::Vector3D >()->z);
HXLINE( 724)				this->rawData[(int)0] = ((cy * cz) * scale->__get((int)0));
HXLINE( 725)				this->rawData[(int)1] = ((cy * sz) * scale->__get((int)1));
HXLINE( 726)				this->rawData[(int)2] = (-(sy) * scale->__get((int)2));
HXLINE( 727)				this->rawData[(int)3] = (int)0;
HXLINE( 728)				this->rawData[(int)4] = ((((sx * sy) * cz) - (cx * sz)) * scale->__get((int)4));
HXLINE( 729)				this->rawData[(int)5] = ((((sx * sy) * sz) + (cx * cz)) * scale->__get((int)5));
HXLINE( 730)				this->rawData[(int)6] = ((sx * cy) * scale->__get((int)6));
HXLINE( 731)				this->rawData[(int)7] = (int)0;
HXLINE( 732)				this->rawData[(int)8] = ((((cx * sy) * cz) + (sx * sz)) * scale->__get((int)8));
HXLINE( 733)				this->rawData[(int)9] = ((((cx * sy) * sz) - (sx * cz)) * scale->__get((int)9));
HXLINE( 734)				this->rawData[(int)10] = ((cx * cy) * scale->__get((int)10));
HXLINE( 735)				this->rawData[(int)11] = (int)0;
HXLINE( 736)				this->rawData[(int)12] = components->__get((int)0).StaticCast<  ::openfl::geom::Vector3D >()->x;
HXLINE( 737)				this->rawData[(int)13] = components->__get((int)0).StaticCast<  ::openfl::geom::Vector3D >()->y;
HXLINE( 738)				this->rawData[(int)14] = components->__get((int)0).StaticCast<  ::openfl::geom::Vector3D >()->z;
HXLINE( 739)				this->rawData[(int)15] = (int)1;
            			}
            			else {
HXLINE( 743)				Float x1 = components->__get((int)1).StaticCast<  ::openfl::geom::Vector3D >()->x;
HXLINE( 744)				Float y1 = components->__get((int)1).StaticCast<  ::openfl::geom::Vector3D >()->y;
HXLINE( 745)				Float z1 = components->__get((int)1).StaticCast<  ::openfl::geom::Vector3D >()->z;
HXLINE( 746)				Float w1 = components->__get((int)1).StaticCast<  ::openfl::geom::Vector3D >()->w;
HXLINE( 748)				if (::Type_obj::enumEq(orientationStyle,(int)0)) {
HXLINE( 750)					x1 = (x1 * ::Math_obj::sin(((Float)w1 / (Float)(int)2)));
HXLINE( 751)					y1 = (y1 * ::Math_obj::sin(((Float)w1 / (Float)(int)2)));
HXLINE( 752)					z1 = (z1 * ::Math_obj::sin(((Float)w1 / (Float)(int)2)));
HXLINE( 753)					w1 = ::Math_obj::cos(((Float)w1 / (Float)(int)2));
            				}
HXLINE( 757)				this->rawData[(int)0] = ((((int)1 - (((int)2 * y1) * y1)) - (((int)2 * z1) * z1)) * scale->__get((int)0));
HXLINE( 758)				this->rawData[(int)1] = (((((int)2 * x1) * y1) + (((int)2 * w1) * z1)) * scale->__get((int)1));
HXLINE( 759)				this->rawData[(int)2] = (((((int)2 * x1) * z1) - (((int)2 * w1) * y1)) * scale->__get((int)2));
HXLINE( 760)				this->rawData[(int)3] = (int)0;
HXLINE( 761)				this->rawData[(int)4] = (((((int)2 * x1) * y1) - (((int)2 * w1) * z1)) * scale->__get((int)4));
HXLINE( 762)				this->rawData[(int)5] = ((((int)1 - (((int)2 * x1) * x1)) - (((int)2 * z1) * z1)) * scale->__get((int)5));
HXLINE( 763)				this->rawData[(int)6] = (((((int)2 * y1) * z1) + (((int)2 * w1) * x1)) * scale->__get((int)6));
HXLINE( 764)				this->rawData[(int)7] = (int)0;
HXLINE( 765)				this->rawData[(int)8] = (((((int)2 * x1) * z1) + (((int)2 * w1) * y1)) * scale->__get((int)8));
HXLINE( 766)				this->rawData[(int)9] = (((((int)2 * y1) * z1) - (((int)2 * w1) * x1)) * scale->__get((int)9));
HXLINE( 767)				this->rawData[(int)10] = ((((int)1 - (((int)2 * x1) * x1)) - (((int)2 * y1) * y1)) * scale->__get((int)10));
HXLINE( 768)				this->rawData[(int)11] = (int)0;
HXLINE( 769)				this->rawData[(int)12] = components->__get((int)0).StaticCast<  ::openfl::geom::Vector3D >()->x;
HXLINE( 770)				this->rawData[(int)13] = components->__get((int)0).StaticCast<  ::openfl::geom::Vector3D >()->y;
HXLINE( 771)				this->rawData[(int)14] = components->__get((int)0).StaticCast<  ::openfl::geom::Vector3D >()->z;
HXLINE( 772)				this->rawData[(int)15] = (int)1;
            			}
            		}
HXLINE( 776)		if ((components->__get((int)2).StaticCast<  ::openfl::geom::Vector3D >()->x == (int)0)) {
HXLINE( 778)			this->rawData[(int)0] = ((Float)1e-15);
            		}
HXLINE( 782)		if ((components->__get((int)2).StaticCast<  ::openfl::geom::Vector3D >()->y == (int)0)) {
HXLINE( 784)			this->rawData[(int)5] = ((Float)1e-15);
            		}
HXLINE( 788)		if ((components->__get((int)2).StaticCast<  ::openfl::geom::Vector3D >()->z == (int)0)) {
HXLINE( 790)			this->rawData[(int)10] = ((Float)1e-15);
            		}
HXLINE( 794)		bool _hx_tmp3;
HXDLIN( 794)		bool _hx_tmp4;
HXDLIN( 794)		if ((components->__get((int)2).StaticCast<  ::openfl::geom::Vector3D >()->x != (int)0)) {
HXLINE( 794)			_hx_tmp4 = (components->__get((int)2).StaticCast<  ::openfl::geom::Vector3D >()->y == (int)0);
            		}
            		else {
HXLINE( 794)			_hx_tmp4 = true;
            		}
HXDLIN( 794)		if (!(_hx_tmp4)) {
HXLINE( 794)			_hx_tmp3 = (components->__get((int)2).StaticCast<  ::openfl::geom::Vector3D >()->y == (int)0);
            		}
            		else {
HXLINE( 794)			_hx_tmp3 = true;
            		}
HXDLIN( 794)		return !(_hx_tmp3);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Matrix3D_obj,recompose,return )

 ::openfl::geom::Vector3D Matrix3D_obj::transformVector( ::openfl::geom::Vector3D v){
            	HX_GC_STACKFRAME(&_hx_pos_48294970c42d50e6_799_transformVector)
HXLINE( 801)		Float x = v->x;
HXLINE( 802)		Float y = v->y;
HXLINE( 803)		Float z = v->z;
HXLINE( 805)		Float _hx_tmp = (x * this->rawData->__get((int)0));
HXDLIN( 805)		Float _hx_tmp1 = (_hx_tmp + (y * this->rawData->__get((int)4)));
HXDLIN( 805)		Float _hx_tmp2 = ((_hx_tmp1 + (z * this->rawData->__get((int)8))) + this->rawData->__get((int)12));
HXDLIN( 805)		Float _hx_tmp3 = (x * this->rawData->__get((int)1));
HXDLIN( 805)		Float _hx_tmp4 = (_hx_tmp3 + (y * this->rawData->__get((int)5)));
HXDLIN( 805)		Float _hx_tmp5 = ((_hx_tmp4 + (z * this->rawData->__get((int)9))) + this->rawData->__get((int)13));
HXDLIN( 805)		Float _hx_tmp6 = (x * this->rawData->__get((int)2));
HXDLIN( 805)		Float _hx_tmp7 = (_hx_tmp6 + (y * this->rawData->__get((int)6)));
HXDLIN( 805)		Float _hx_tmp8 = ((_hx_tmp7 + (z * this->rawData->__get((int)10))) + this->rawData->__get((int)14));
HXDLIN( 805)		Float _hx_tmp9 = (x * this->rawData->__get((int)3));
HXDLIN( 805)		Float _hx_tmp10 = (_hx_tmp9 + (y * this->rawData->__get((int)7)));
HXDLIN( 805)		return  ::openfl::geom::Vector3D_obj::__alloc( HX_CTX ,_hx_tmp2,_hx_tmp5,_hx_tmp8,((_hx_tmp10 + (z * this->rawData->__get((int)11))) + this->rawData->__get((int)15)));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Matrix3D_obj,transformVector,return )

void Matrix3D_obj::transformVectors(::Array< Float > vin,::Array< Float > vout){
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_810_transformVectors)
HXLINE( 812)		int i = (int)0;
HXLINE( 813)		 ::Dynamic x;
HXDLIN( 813)		 ::Dynamic y;
HXDLIN( 813)		 ::Dynamic z;
HXLINE( 815)		while(((i + (int)3) <= vin->length)){
HXLINE( 817)			x = vin->__get(i);
HXLINE( 818)			y = vin->__get((i + (int)1));
HXLINE( 819)			z = vin->__get((i + (int)2));
HXLINE( 821)			{
HXLINE( 821)				Float value = (x * this->rawData->__get((int)0));
HXDLIN( 821)				Float value1 = (value + (y * this->rawData->__get((int)4)));
HXDLIN( 821)				vout[i] = ((value1 + (z * this->rawData->__get((int)8))) + this->rawData->__get((int)12));
            			}
HXLINE( 822)			{
HXLINE( 822)				Float value2 = (x * this->rawData->__get((int)1));
HXDLIN( 822)				Float value3 = (value2 + (y * this->rawData->__get((int)5)));
HXDLIN( 822)				vout[(i + (int)1)] = ((value3 + (z * this->rawData->__get((int)9))) + this->rawData->__get((int)13));
            			}
HXLINE( 823)			{
HXLINE( 823)				Float value4 = (x * this->rawData->__get((int)2));
HXDLIN( 823)				Float value5 = (value4 + (y * this->rawData->__get((int)6)));
HXDLIN( 823)				vout[(i + (int)2)] = ((value5 + (z * this->rawData->__get((int)10))) + this->rawData->__get((int)14));
            			}
HXLINE( 825)			i = (i + (int)3);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Matrix3D_obj,transformVectors,(void))

void Matrix3D_obj::transpose(){
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_832_transpose)
HXLINE( 834)		::Array< Float > oRawData = this->rawData->copy();
HXLINE( 835)		this->rawData[(int)1] = oRawData->__get((int)4);
HXLINE( 836)		this->rawData[(int)2] = oRawData->__get((int)8);
HXLINE( 837)		this->rawData[(int)3] = oRawData->__get((int)12);
HXLINE( 838)		this->rawData[(int)4] = oRawData->__get((int)1);
HXLINE( 839)		this->rawData[(int)6] = oRawData->__get((int)9);
HXLINE( 840)		this->rawData[(int)7] = oRawData->__get((int)13);
HXLINE( 841)		this->rawData[(int)8] = oRawData->__get((int)2);
HXLINE( 842)		this->rawData[(int)9] = oRawData->__get((int)6);
HXLINE( 843)		this->rawData[(int)11] = oRawData->__get((int)14);
HXLINE( 844)		this->rawData[(int)12] = oRawData->__get((int)3);
HXLINE( 845)		this->rawData[(int)13] = oRawData->__get((int)7);
HXLINE( 846)		this->rawData[(int)14] = oRawData->__get((int)11);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Matrix3D_obj,transpose,(void))

Float Matrix3D_obj::get_determinant(){
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_892_get_determinant)
HXDLIN( 892)		Float _hx_tmp = (this->rawData->__get((int)0) * this->rawData->__get((int)5));
HXDLIN( 892)		Float _hx_tmp1 = (_hx_tmp - (this->rawData->__get((int)4) * this->rawData->__get((int)1)));
HXDLIN( 892)		Float _hx_tmp2 = (this->rawData->__get((int)10) * this->rawData->__get((int)15));
HXDLIN( 892)		Float _hx_tmp3 = (_hx_tmp1 * (_hx_tmp2 - (this->rawData->__get((int)14) * this->rawData->__get((int)11))));
HXLINE( 893)		Float _hx_tmp4 = (this->rawData->__get((int)0) * this->rawData->__get((int)9));
HXDLIN( 893)		Float _hx_tmp5 = (_hx_tmp4 - (this->rawData->__get((int)8) * this->rawData->__get((int)1)));
HXDLIN( 893)		Float _hx_tmp6 = (this->rawData->__get((int)6) * this->rawData->__get((int)15));
HXLINE( 892)		Float _hx_tmp7 = (_hx_tmp3 - (_hx_tmp5 * (_hx_tmp6 - (this->rawData->__get((int)14) * this->rawData->__get((int)7)))));
HXLINE( 894)		Float _hx_tmp8 = (this->rawData->__get((int)0) * this->rawData->__get((int)13));
HXDLIN( 894)		Float _hx_tmp9 = (_hx_tmp8 - (this->rawData->__get((int)12) * this->rawData->__get((int)1)));
HXDLIN( 894)		Float _hx_tmp10 = (this->rawData->__get((int)6) * this->rawData->__get((int)11));
HXLINE( 892)		Float _hx_tmp11 = (_hx_tmp7 + (_hx_tmp9 * (_hx_tmp10 - (this->rawData->__get((int)10) * this->rawData->__get((int)7)))));
HXLINE( 895)		Float _hx_tmp12 = (this->rawData->__get((int)4) * this->rawData->__get((int)9));
HXDLIN( 895)		Float _hx_tmp13 = (_hx_tmp12 - (this->rawData->__get((int)8) * this->rawData->__get((int)5)));
HXDLIN( 895)		Float _hx_tmp14 = (this->rawData->__get((int)2) * this->rawData->__get((int)15));
HXLINE( 892)		Float _hx_tmp15 = (_hx_tmp11 + (_hx_tmp13 * (_hx_tmp14 - (this->rawData->__get((int)14) * this->rawData->__get((int)3)))));
HXLINE( 896)		Float _hx_tmp16 = (this->rawData->__get((int)4) * this->rawData->__get((int)13));
HXDLIN( 896)		Float _hx_tmp17 = (_hx_tmp16 - (this->rawData->__get((int)12) * this->rawData->__get((int)5)));
HXDLIN( 896)		Float _hx_tmp18 = (this->rawData->__get((int)2) * this->rawData->__get((int)11));
HXLINE( 892)		Float _hx_tmp19 = (_hx_tmp15 - (_hx_tmp17 * (_hx_tmp18 - (this->rawData->__get((int)10) * this->rawData->__get((int)3)))));
HXLINE( 897)		Float _hx_tmp20 = (this->rawData->__get((int)8) * this->rawData->__get((int)13));
HXDLIN( 897)		Float _hx_tmp21 = (_hx_tmp20 - (this->rawData->__get((int)12) * this->rawData->__get((int)9)));
HXDLIN( 897)		Float _hx_tmp22 = (this->rawData->__get((int)2) * this->rawData->__get((int)7));
HXLINE( 892)		return (_hx_tmp19 + (_hx_tmp21 * (_hx_tmp22 - (this->rawData->__get((int)6) * this->rawData->__get((int)3)))));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Matrix3D_obj,get_determinant,return )

 ::openfl::geom::Vector3D Matrix3D_obj::get_position(){
            	HX_GC_STACKFRAME(&_hx_pos_48294970c42d50e6_904_get_position)
HXDLIN( 904)		return  ::openfl::geom::Vector3D_obj::__alloc( HX_CTX ,this->rawData->__get((int)12),this->rawData->__get((int)13),this->rawData->__get((int)14),null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(Matrix3D_obj,get_position,return )

 ::openfl::geom::Vector3D Matrix3D_obj::set_position( ::openfl::geom::Vector3D val){
            	HX_STACKFRAME(&_hx_pos_48294970c42d50e6_909_set_position)
HXLINE( 911)		this->rawData[(int)12] = val->x;
HXLINE( 912)		this->rawData[(int)13] = val->y;
HXLINE( 913)		this->rawData[(int)14] = val->z;
HXLINE( 914)		return val;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Matrix3D_obj,set_position,return )

 ::openfl::geom::Matrix3D Matrix3D_obj::create2D(Float x,Float y,hx::Null< Float >  __o_scale,hx::Null< Float >  __o_rotation){
Float scale = __o_scale.Default(1);
Float rotation = __o_rotation.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_48294970c42d50e6_324_create2D)
HXLINE( 326)		Float theta = ((Float)(rotation * ::Math_obj::PI) / (Float)((Float)180.0));
HXLINE( 327)		Float c = ::Math_obj::cos(theta);
HXLINE( 328)		Float s = ::Math_obj::sin(theta);
HXLINE( 330)		return  ::openfl::geom::Matrix3D_obj::__alloc( HX_CTX ,::Array_obj< Float >::__new(16)->init(0,(c * scale))->init(1,(-(s) * scale))->init(2,(int)0)->init(3,(int)0)->init(4,(s * scale))->init(5,(c * scale))->init(6,(int)0)->init(7,(int)0)->init(8,(int)0)->init(9,(int)0)->init(10,(int)1)->init(11,(int)0)->init(12,x)->init(13,y)->init(14,(int)0)->init(15,(int)1));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Matrix3D_obj,create2D,return )

 ::openfl::geom::Matrix3D Matrix3D_obj::createABCD(Float a,Float b,Float c,Float d,Float tx,Float ty){
            	HX_GC_STACKFRAME(&_hx_pos_48294970c42d50e6_337_createABCD)
HXDLIN( 337)		return  ::openfl::geom::Matrix3D_obj::__alloc( HX_CTX ,::Array_obj< Float >::__new(16)->init(0,a)->init(1,b)->init(2,(int)0)->init(3,(int)0)->init(4,c)->init(5,d)->init(6,(int)0)->init(7,(int)0)->init(8,(int)0)->init(9,(int)0)->init(10,(int)1)->init(11,(int)0)->init(12,tx)->init(13,ty)->init(14,(int)0)->init(15,(int)1));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Matrix3D_obj,createABCD,return )

 ::openfl::geom::Matrix3D Matrix3D_obj::createOrtho(Float x0,Float x1,Float y0,Float y1,Float zNear,Float zFar){
            	HX_GC_STACKFRAME(&_hx_pos_48294970c42d50e6_342_createOrtho)
HXLINE( 344)		Float sx = ((Float)((Float)1.0) / (Float)(x1 - x0));
HXLINE( 345)		Float sy = ((Float)((Float)1.0) / (Float)(y1 - y0));
HXLINE( 346)		Float sz = ((Float)((Float)1.0) / (Float)(zFar - zNear));
HXLINE( 348)		return  ::openfl::geom::Matrix3D_obj::__alloc( HX_CTX ,::Array_obj< Float >::__new(16)->init(0,(((Float)2.0) * sx))->init(1,(int)0)->init(2,(int)0)->init(3,(int)0)->init(4,(int)0)->init(5,(((Float)2.0) * sy))->init(6,(int)0)->init(7,(int)0)->init(8,(int)0)->init(9,(int)0)->init(10,(((Float)-2.0) * sz))->init(11,(int)0)->init(12,(-((x0 + x1)) * sx))->init(13,(-((y0 + y1)) * sy))->init(14,(-((zNear + zFar)) * sz))->init(15,(int)1));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC6(Matrix3D_obj,createOrtho,return )

 ::openfl::geom::Matrix3D Matrix3D_obj::interpolate( ::openfl::geom::Matrix3D thisMat, ::openfl::geom::Matrix3D toMat,Float percent){
            	HX_GC_STACKFRAME(&_hx_pos_48294970c42d50e6_495_interpolate)
HXLINE( 497)		 ::openfl::geom::Matrix3D m =  ::openfl::geom::Matrix3D_obj::__alloc( HX_CTX ,null());
HXLINE( 499)		{
HXLINE( 499)			int _g = (int)0;
HXDLIN( 499)			while((_g < (int)16)){
HXLINE( 499)				_g = (_g + (int)1);
HXDLIN( 499)				int i = (_g - (int)1);
HXLINE( 501)				{
HXLINE( 501)					 ::Dynamic value = thisMat->rawData->__get(i);
HXDLIN( 501)					m->rawData[i] = (value + ((toMat->rawData->__get(i) - thisMat->rawData->__get(i)) * percent));
            				}
            			}
            		}
HXLINE( 505)		return m;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Matrix3D_obj,interpolate,return )

 ::openfl::geom::Matrix3D Matrix3D_obj::_hx___getAxisRotation(Float x,Float y,Float z,Float degrees){
            	HX_GC_STACKFRAME(&_hx_pos_48294970c42d50e6_851___getAxisRotation)
HXLINE( 853)		 ::openfl::geom::Matrix3D m =  ::openfl::geom::Matrix3D_obj::__alloc( HX_CTX ,null());
HXLINE( 855)		 ::openfl::geom::Vector3D a1 =  ::openfl::geom::Vector3D_obj::__alloc( HX_CTX ,x,y,z,null());
HXLINE( 856)		Float rad = (-(degrees) * ((Float)::Math_obj::PI / (Float)(int)180));
HXLINE( 857)		Float c = ::Math_obj::cos(rad);
HXLINE( 858)		Float s = ::Math_obj::sin(rad);
HXLINE( 859)		Float t = (((Float)1.0) - c);
HXLINE( 861)		m->rawData[(int)0] = (c + ((a1->x * a1->x) * t));
HXLINE( 862)		m->rawData[(int)5] = (c + ((a1->y * a1->y) * t));
HXLINE( 863)		m->rawData[(int)10] = (c + ((a1->z * a1->z) * t));
HXLINE( 865)		Float tmp1 = ((a1->x * a1->y) * t);
HXLINE( 866)		Float tmp2 = (a1->z * s);
HXLINE( 867)		m->rawData[(int)4] = (tmp1 + tmp2);
HXLINE( 868)		m->rawData[(int)1] = (tmp1 - tmp2);
HXLINE( 869)		tmp1 = ((a1->x * a1->z) * t);
HXLINE( 870)		tmp2 = (a1->y * s);
HXLINE( 871)		m->rawData[(int)8] = (tmp1 - tmp2);
HXLINE( 872)		m->rawData[(int)2] = (tmp1 + tmp2);
HXLINE( 873)		tmp1 = ((a1->y * a1->z) * t);
HXLINE( 874)		tmp2 = (a1->x * s);
HXLINE( 875)		m->rawData[(int)9] = (tmp1 + tmp2);
HXLINE( 876)		m->rawData[(int)6] = (tmp1 - tmp2);
HXLINE( 878)		return m;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Matrix3D_obj,_hx___getAxisRotation,return )


hx::ObjectPtr< Matrix3D_obj > Matrix3D_obj::__new(::Array< Float > v) {
	hx::ObjectPtr< Matrix3D_obj > __this = new Matrix3D_obj();
	__this->__construct(v);
	return __this;
}

hx::ObjectPtr< Matrix3D_obj > Matrix3D_obj::__alloc(hx::Ctx *_hx_ctx,::Array< Float > v) {
	Matrix3D_obj *__this = (Matrix3D_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Matrix3D_obj), true, "openfl.geom.Matrix3D"));
	*(void **)__this = Matrix3D_obj::_hx_vtable;
	__this->__construct(v);
	return __this;
}

Matrix3D_obj::Matrix3D_obj()
{
}

void Matrix3D_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Matrix3D);
	HX_MARK_MEMBER_NAME(determinant,"determinant");
	HX_MARK_MEMBER_NAME(rawData,"rawData");
	HX_MARK_END_CLASS();
}

void Matrix3D_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(determinant,"determinant");
	HX_VISIT_MEMBER_NAME(rawData,"rawData");
}

hx::Val Matrix3D_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"clone") ) { return hx::Val( clone_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"append") ) { return hx::Val( append_dyn() ); }
		if (HX_FIELD_EQ(inName,"invert") ) { return hx::Val( invert_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"rawData") ) { return hx::Val( rawData ); }
		if (HX_FIELD_EQ(inName,"pointAt") ) { return hx::Val( pointAt_dyn() ); }
		if (HX_FIELD_EQ(inName,"prepend") ) { return hx::Val( prepend_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"position") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_position() ); }
		if (HX_FIELD_EQ(inName,"copyFrom") ) { return hx::Val( copyFrom_dyn() ); }
		if (HX_FIELD_EQ(inName,"identity") ) { return hx::Val( identity_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"copyRowTo") ) { return hx::Val( copyRowTo_dyn() ); }
		if (HX_FIELD_EQ(inName,"decompose") ) { return hx::Val( decompose_dyn() ); }
		if (HX_FIELD_EQ(inName,"recompose") ) { return hx::Val( recompose_dyn() ); }
		if (HX_FIELD_EQ(inName,"transpose") ) { return hx::Val( transpose_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"determinant") ) { return hx::Val( inCallProp == hx::paccAlways ? get_determinant() : determinant ); }
		if (HX_FIELD_EQ(inName,"appendScale") ) { return hx::Val( appendScale_dyn() ); }
		if (HX_FIELD_EQ(inName,"copyRowFrom") ) { return hx::Val( copyRowFrom_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"copyColumnTo") ) { return hx::Val( copyColumnTo_dyn() ); }
		if (HX_FIELD_EQ(inName,"prependScale") ) { return hx::Val( prependScale_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_position") ) { return hx::Val( get_position_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_position") ) { return hx::Val( set_position_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"copyRawDataTo") ) { return hx::Val( copyRawDataTo_dyn() ); }
		if (HX_FIELD_EQ(inName,"interpolateTo") ) { return hx::Val( interpolateTo_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"appendRotation") ) { return hx::Val( appendRotation_dyn() ); }
		if (HX_FIELD_EQ(inName,"copyColumnFrom") ) { return hx::Val( copyColumnFrom_dyn() ); }
		if (HX_FIELD_EQ(inName,"copyToMatrix3D") ) { return hx::Val( copyToMatrix3D_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"copyRawDataFrom") ) { return hx::Val( copyRawDataFrom_dyn() ); }
		if (HX_FIELD_EQ(inName,"prependRotation") ) { return hx::Val( prependRotation_dyn() ); }
		if (HX_FIELD_EQ(inName,"transformVector") ) { return hx::Val( transformVector_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_determinant") ) { return hx::Val( get_determinant_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"transformVectors") ) { return hx::Val( transformVectors_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"appendTranslation") ) { return hx::Val( appendTranslation_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"prependTranslation") ) { return hx::Val( prependTranslation_dyn() ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"deltaTransformVector") ) { return hx::Val( deltaTransformVector_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Matrix3D_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"create2D") ) { outValue = create2D_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"createABCD") ) { outValue = createABCD_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"createOrtho") ) { outValue = createOrtho_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"interpolate") ) { outValue = interpolate_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"__getAxisRotation") ) { outValue = _hx___getAxisRotation_dyn(); return true; }
	}
	return false;
}

hx::Val Matrix3D_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"rawData") ) { rawData=inValue.Cast< ::Array< Float > >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"position") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_position(inValue.Cast<  ::openfl::geom::Vector3D >()) ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"determinant") ) { determinant=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Matrix3D_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("determinant","\x95","\x5d","\x15","\x32"));
	outFields->push(HX_HCSTRING("position","\xa9","\xa0","\xfa","\xca"));
	outFields->push(HX_HCSTRING("rawData","\x32","\x6c","\x18","\xff"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Matrix3D_obj_sMemberStorageInfo[] = {
	{hx::fsFloat,(int)offsetof(Matrix3D_obj,determinant),HX_HCSTRING("determinant","\x95","\x5d","\x15","\x32")},
	{hx::fsObject /*Array< Float >*/ ,(int)offsetof(Matrix3D_obj,rawData),HX_HCSTRING("rawData","\x32","\x6c","\x18","\xff")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Matrix3D_obj_sStaticStorageInfo = 0;
#endif

static ::String Matrix3D_obj_sMemberFields[] = {
	HX_HCSTRING("determinant","\x95","\x5d","\x15","\x32"),
	HX_HCSTRING("rawData","\x32","\x6c","\x18","\xff"),
	HX_HCSTRING("append","\xda","\xe1","\xd3","\x8f"),
	HX_HCSTRING("appendRotation","\x38","\x45","\xe8","\xcb"),
	HX_HCSTRING("appendScale","\x50","\x66","\x45","\xb5"),
	HX_HCSTRING("appendTranslation","\x37","\xe1","\x3d","\xd6"),
	HX_HCSTRING("clone","\x5d","\x13","\x63","\x48"),
	HX_HCSTRING("copyColumnFrom","\x75","\x97","\xb5","\x3a"),
	HX_HCSTRING("copyColumnTo","\xc6","\x2e","\xf6","\xf6"),
	HX_HCSTRING("copyFrom","\xbf","\x0b","\x61","\xc8"),
	HX_HCSTRING("copyRawDataFrom","\x07","\x7d","\xbd","\x2c"),
	HX_HCSTRING("copyRawDataTo","\xd8","\x2b","\xf7","\xa8"),
	HX_HCSTRING("copyRowFrom","\x6f","\x45","\x8b","\xef"),
	HX_HCSTRING("copyRowTo","\x40","\x8a","\x62","\x73"),
	HX_HCSTRING("copyToMatrix3D","\xe2","\x1d","\x1f","\x04"),
	HX_HCSTRING("decompose","\xb1","\xc3","\xa7","\x7a"),
	HX_HCSTRING("deltaTransformVector","\x37","\x02","\x9c","\xc2"),
	HX_HCSTRING("identity","\x3e","\x45","\x2f","\xb9"),
	HX_HCSTRING("interpolateTo","\x9c","\x90","\x22","\x71"),
	HX_HCSTRING("invert","\x16","\xe7","\xd8","\x9f"),
	HX_HCSTRING("pointAt","\x63","\xa1","\x21","\x51"),
	HX_HCSTRING("prepend","\x0e","\x97","\xe0","\x37"),
	HX_HCSTRING("prependRotation","\x6c","\x4e","\x3b","\xe8"),
	HX_HCSTRING("prependScale","\x9c","\x54","\x97","\xc4"),
	HX_HCSTRING("prependTranslation","\x83","\x90","\x15","\x05"),
	HX_HCSTRING("recompose","\xbf","\x81","\xdb","\x03"),
	HX_HCSTRING("transformVector","\x4f","\x2b","\xb3","\xd2"),
	HX_HCSTRING("transformVectors","\x44","\xba","\x12","\x8a"),
	HX_HCSTRING("transpose","\x79","\x50","\x2f","\x4c"),
	HX_HCSTRING("get_determinant","\x2c","\x15","\xf7","\xf2"),
	HX_HCSTRING("get_position","\xb2","\x54","\x14","\x80"),
	HX_HCSTRING("set_position","\x26","\x78","\x0d","\x95"),
	::String(null()) };

static void Matrix3D_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Matrix3D_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Matrix3D_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Matrix3D_obj::__mClass,"__mClass");
};

#endif

hx::Class Matrix3D_obj::__mClass;

static ::String Matrix3D_obj_sStaticFields[] = {
	HX_HCSTRING("create2D","\xce","\x49","\xf4","\x2b"),
	HX_HCSTRING("createABCD","\xbe","\xc2","\xdd","\x52"),
	HX_HCSTRING("createOrtho","\x9c","\x4e","\xa8","\x5e"),
	HX_HCSTRING("interpolate","\xc1","\xd4","\x32","\x1f"),
	HX_HCSTRING("__getAxisRotation","\x95","\xa5","\x44","\x7b"),
	::String(null())
};

void Matrix3D_obj::__register()
{
	hx::Object *dummy = new Matrix3D_obj;
	Matrix3D_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("openfl.geom.Matrix3D","\xe6","\x93","\x2e","\x3d");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Matrix3D_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Matrix3D_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Matrix3D_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Matrix3D_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Matrix3D_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Matrix3D_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Matrix3D_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Matrix3D_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace openfl
} // end namespace geom
