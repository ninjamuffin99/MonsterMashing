// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMatrix
#include <flixel/math/FlxMatrix.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRect
#include <flixel/math/FlxRect.h>
#endif
#ifndef INCLUDED_flixel_util_FlxBitmapDataUtil
#include <flixel/util/FlxBitmapDataUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxPoint
#include <flixel/util/FlxPool_flixel_math_FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxRect
#include <flixel/util/FlxPool_flixel_math_FlxRect.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_flixel_util__FlxColor_FlxColor_Impl_
#include <flixel/util/_FlxColor/FlxColor_Impl_.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_BitmapData
#include <openfl/_legacy/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_BlendMode
#include <openfl/_legacy/display/BlendMode.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_IBitmapDrawable
#include <openfl/_legacy/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_ColorTransform
#include <openfl/_legacy/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Matrix
#include <openfl/_legacy/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Point
#include <openfl/_legacy/geom/Point.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Rectangle
#include <openfl/_legacy/geom/Rectangle.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_32_merge,"flixel.util.FlxBitmapDataUtil","merge",0x21db12bd,"flixel.util.FlxBitmapDataUtil.merge","flixel/util/FlxBitmapDataUtil.hx",32,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_149_mergeColorComponent,"flixel.util.FlxBitmapDataUtil","mergeColorComponent",0x5b71b277,"flixel.util.FlxBitmapDataUtil.mergeColorComponent","flixel/util/FlxBitmapDataUtil.hx",149,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_164_compare,"flixel.util.FlxBitmapDataUtil","compare",0x217d53ea,"flixel.util.FlxBitmapDataUtil.compare","flixel/util/FlxBitmapDataUtil.hx",164,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_232_getDiff,"flixel.util.FlxBitmapDataUtil","getDiff",0xb3004700,"flixel.util.FlxBitmapDataUtil.getDiff","flixel/util/FlxBitmapDataUtil.hx",232,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_242_getMemorySize,"flixel.util.FlxBitmapDataUtil","getMemorySize",0x5bc2859d,"flixel.util.FlxBitmapDataUtil.getMemorySize","flixel/util/FlxBitmapDataUtil.hx",242,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_257_replaceColor,"flixel.util.FlxBitmapDataUtil","replaceColor",0xbc41272a,"flixel.util.FlxBitmapDataUtil.replaceColor","flixel/util/FlxBitmapDataUtil.hx",257,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_326_addSpacesAndBorders,"flixel.util.FlxBitmapDataUtil","addSpacesAndBorders",0xf8f1a643,"flixel.util.FlxBitmapDataUtil.addSpacesAndBorders","flixel/util/FlxBitmapDataUtil.hx",326,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_409_copyBorderPixels,"flixel.util.FlxBitmapDataUtil","copyBorderPixels",0x739e20a9,"flixel.util.FlxBitmapDataUtil.copyBorderPixels","flixel/util/FlxBitmapDataUtil.hx",409,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_469_generateRotations,"flixel.util.FlxBitmapDataUtil","generateRotations",0xe085af05,"flixel.util.FlxBitmapDataUtil.generateRotations","flixel/util/FlxBitmapDataUtil.hx",469,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_17_boot,"flixel.util.FlxBitmapDataUtil","boot",0x2db7bbcd,"flixel.util.FlxBitmapDataUtil.boot","flixel/util/FlxBitmapDataUtil.hx",17,0xf477b24b)
namespace flixel{
namespace util{

void FlxBitmapDataUtil_obj::__construct() { }

Dynamic FlxBitmapDataUtil_obj::__CreateEmpty() { return new FlxBitmapDataUtil_obj; }

void *FlxBitmapDataUtil_obj::_hx_vtable = 0;

Dynamic FlxBitmapDataUtil_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< FlxBitmapDataUtil_obj > _hx_result = new FlxBitmapDataUtil_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool FlxBitmapDataUtil_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x1b702c2f;
}

 ::flixel::math::FlxMatrix FlxBitmapDataUtil_obj::matrix;

void FlxBitmapDataUtil_obj::merge( ::openfl::_legacy::display::BitmapData sourceBitmapData, ::openfl::_legacy::geom::Rectangle sourceRect, ::openfl::_legacy::display::BitmapData destBitmapData, ::openfl::_legacy::geom::Point destPoint,int redMultiplier,int greenMultiplier,int blueMultiplier,int alphaMultiplier){
            	HX_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_32_merge)
HXLINE(  36)		bool _hx_tmp;
HXDLIN(  36)		bool _hx_tmp1;
HXDLIN(  36)		bool _hx_tmp2;
HXDLIN(  36)		bool _hx_tmp3;
HXDLIN(  36)		bool _hx_tmp4;
HXDLIN(  36)		Float destPoint1 = destPoint->x;
HXDLIN(  36)		if (!((destPoint1 >= destBitmapData->get_width()))) {
HXLINE(  37)			Float destPoint2 = destPoint->y;
HXLINE(  36)			_hx_tmp4 = (destPoint2 >= destBitmapData->get_height());
            		}
            		else {
HXLINE(  36)			_hx_tmp4 = true;
            		}
HXDLIN(  36)		if (!(_hx_tmp4)) {
HXLINE(  38)			Float sourceRect1 = sourceRect->x;
HXLINE(  36)			_hx_tmp3 = (sourceRect1 >= sourceBitmapData->get_width());
            		}
            		else {
HXLINE(  36)			_hx_tmp3 = true;
            		}
HXDLIN(  36)		if (!(_hx_tmp3)) {
HXLINE(  39)			Float sourceRect2 = sourceRect->y;
HXLINE(  36)			_hx_tmp2 = (sourceRect2 >= sourceBitmapData->get_height());
            		}
            		else {
HXLINE(  36)			_hx_tmp2 = true;
            		}
HXDLIN(  36)		if (!(_hx_tmp2)) {
HXLINE(  36)			_hx_tmp1 = ((sourceRect->x + sourceRect->width) <= (int)0);
            		}
            		else {
HXLINE(  36)			_hx_tmp1 = true;
            		}
HXDLIN(  36)		if (!(_hx_tmp1)) {
HXLINE(  36)			_hx_tmp = ((sourceRect->y + sourceRect->height) <= (int)0);
            		}
            		else {
HXLINE(  36)			_hx_tmp = true;
            		}
HXDLIN(  36)		if (_hx_tmp) {
HXLINE(  43)			return;
            		}
HXLINE(  47)		while(true){
HXLINE(  47)			bool _hx_tmp5;
HXDLIN(  47)			bool _hx_tmp6;
HXDLIN(  47)			bool _hx_tmp7;
HXDLIN(  47)			bool _hx_tmp8;
HXDLIN(  47)			bool _hx_tmp9;
HXDLIN(  47)			Float _hx_tmp10 = (sourceRect->x + sourceRect->width);
HXDLIN(  47)			if (!((_hx_tmp10 > sourceBitmapData->get_width()))) {
HXLINE(  48)				Float _hx_tmp11 = (sourceRect->y + sourceRect->height);
HXLINE(  47)				_hx_tmp9 = (_hx_tmp11 > sourceBitmapData->get_height());
            			}
            			else {
HXLINE(  47)				_hx_tmp9 = true;
            			}
HXDLIN(  47)			if (!(_hx_tmp9)) {
HXLINE(  47)				_hx_tmp8 = (sourceRect->x < (int)0);
            			}
            			else {
HXLINE(  47)				_hx_tmp8 = true;
            			}
HXDLIN(  47)			if (!(_hx_tmp8)) {
HXLINE(  47)				_hx_tmp7 = (sourceRect->y < (int)0);
            			}
            			else {
HXLINE(  47)				_hx_tmp7 = true;
            			}
HXDLIN(  47)			if (!(_hx_tmp7)) {
HXLINE(  47)				_hx_tmp6 = (destPoint->x < (int)0);
            			}
            			else {
HXLINE(  47)				_hx_tmp6 = true;
            			}
HXDLIN(  47)			if (!(_hx_tmp6)) {
HXLINE(  47)				_hx_tmp5 = (destPoint->y < (int)0);
            			}
            			else {
HXLINE(  47)				_hx_tmp5 = true;
            			}
HXDLIN(  47)			if (!(_hx_tmp5)) {
HXLINE(  47)				goto _hx_goto_0;
            			}
HXLINE(  54)			Float _hx_tmp12 = (sourceRect->x + sourceRect->width);
HXDLIN(  54)			if ((_hx_tmp12 > sourceBitmapData->get_width())) {
HXLINE(  54)				int _hx_tmp13 = sourceBitmapData->get_width();
HXDLIN(  54)				sourceRect->width = (_hx_tmp13 - sourceRect->x);
            			}
HXLINE(  55)			Float _hx_tmp14 = (sourceRect->y + sourceRect->height);
HXDLIN(  55)			if ((_hx_tmp14 > sourceBitmapData->get_height())) {
HXLINE(  55)				int _hx_tmp15 = sourceBitmapData->get_height();
HXDLIN(  55)				sourceRect->height = (_hx_tmp15 - sourceRect->y);
            			}
HXLINE(  57)			if ((sourceRect->x < (int)0)) {
HXLINE(  59)				destPoint->x = (destPoint->x - sourceRect->x);
HXLINE(  60)				sourceRect->width = (sourceRect->width + sourceRect->x);
HXLINE(  61)				sourceRect->x = (int)0;
            			}
HXLINE(  64)			if ((sourceRect->y < (int)0)) {
HXLINE(  66)				destPoint->y = (destPoint->y - sourceRect->y);
HXLINE(  67)				sourceRect->height = (sourceRect->height + sourceRect->y);
HXLINE(  68)				sourceRect->y = (int)0;
            			}
HXLINE(  71)			bool _hx_tmp16;
HXDLIN(  71)			Float destPoint3 = destPoint->x;
HXDLIN(  71)			if (!((destPoint3 >= destBitmapData->get_width()))) {
HXLINE(  71)				Float destPoint4 = destPoint->y;
HXDLIN(  71)				_hx_tmp16 = (destPoint4 >= destBitmapData->get_height());
            			}
            			else {
HXLINE(  71)				_hx_tmp16 = true;
            			}
HXDLIN(  71)			if (_hx_tmp16) {
HXLINE(  71)				return;
            			}
HXLINE(  73)			if ((destPoint->x < (int)0)) {
HXLINE(  75)				sourceRect->x = (sourceRect->x - destPoint->x);
HXLINE(  76)				sourceRect->width = (sourceRect->width + destPoint->x);
HXLINE(  77)				destPoint->x = (int)0;
            			}
HXLINE(  80)			if ((destPoint->y < (int)0)) {
HXLINE(  82)				sourceRect->y = (sourceRect->y - destPoint->y);
HXLINE(  83)				sourceRect->height = (sourceRect->height + destPoint->y);
HXLINE(  84)				destPoint->y = (int)0;
            			}
            		}
            		_hx_goto_0:;
HXLINE(  88)		bool _hx_tmp17;
HXDLIN(  88)		if (!((sourceRect->width <= (int)0))) {
HXLINE(  88)			_hx_tmp17 = (sourceRect->height <= (int)0);
            		}
            		else {
HXLINE(  88)			_hx_tmp17 = true;
            		}
HXDLIN(  88)		if (_hx_tmp17) {
HXLINE(  88)			return;
            		}
HXLINE(  90)		int startSourceX = ::Math_obj::round(sourceRect->x);
HXLINE(  91)		int startSourceY = ::Math_obj::round(sourceRect->y);
HXLINE(  93)		int width = ::Math_obj::round(sourceRect->width);
HXLINE(  94)		int height = ::Math_obj::round(sourceRect->height);
HXLINE(  96)		int sourceX = startSourceX;
HXLINE(  97)		int sourceY = startSourceY;
HXLINE(  99)		int destX = ::Math_obj::round(destPoint->x);
HXLINE( 100)		int destY = ::Math_obj::round(destPoint->y);
HXLINE( 102)		int currX = destX;
HXLINE( 103)		int currY = destY;
HXLINE( 105)		int sourceColor;
HXLINE( 106)		int destColor;
HXLINE( 108)		int resultRed;
HXLINE( 109)		int resultGreen;
HXLINE( 110)		int resultBlue;
HXLINE( 111)		int resultAlpha;
HXLINE( 113)		int resultColor = (int)0;
HXLINE( 114)		destBitmapData->lock();
HXLINE( 117)		{
HXLINE( 117)			int _g1 = (int)0;
HXDLIN( 117)			int _g = width;
HXDLIN( 117)			while((_g1 < _g)){
HXLINE( 117)				_g1 = (_g1 + (int)1);
HXDLIN( 117)				int i = (_g1 - (int)1);
HXLINE( 119)				{
HXLINE( 119)					int _g3 = (int)0;
HXDLIN( 119)					int _g2 = height;
HXDLIN( 119)					while((_g3 < _g2)){
HXLINE( 119)						_g3 = (_g3 + (int)1);
HXDLIN( 119)						int j = (_g3 - (int)1);
HXLINE( 121)						sourceX = (startSourceX + i);
HXLINE( 122)						sourceY = (startSourceY + j);
HXLINE( 124)						currX = (destX + i);
HXLINE( 125)						currY = (destY + j);
HXLINE( 127)						sourceColor = sourceBitmapData->getPixel32(sourceX,sourceY);
HXLINE( 128)						destColor = destBitmapData->getPixel32(currX,currY);
HXLINE( 131)						resultRed = ::Std_obj::_hx_int(((Float)((((int)((int)sourceColor >> (int)(int)16) & (int)(int)255) * redMultiplier) + (((int)((int)destColor >> (int)(int)16) & (int)(int)255) * ((int)256 - redMultiplier))) / (Float)(int)256));
HXLINE( 132)						resultGreen = ::Std_obj::_hx_int(((Float)((((int)((int)sourceColor >> (int)(int)8) & (int)(int)255) * greenMultiplier) + (((int)((int)destColor >> (int)(int)8) & (int)(int)255) * ((int)256 - greenMultiplier))) / (Float)(int)256));
HXLINE( 133)						resultBlue = ::Std_obj::_hx_int(((Float)((((int)sourceColor & (int)(int)255) * blueMultiplier) + (((int)destColor & (int)(int)255) * ((int)256 - blueMultiplier))) / (Float)(int)256));
HXLINE( 134)						resultAlpha = ::Std_obj::_hx_int(((Float)((((int)((int)sourceColor >> (int)(int)24) & (int)(int)255) * alphaMultiplier) + (((int)((int)destColor >> (int)(int)24) & (int)(int)255) * ((int)256 - alphaMultiplier))) / (Float)(int)256));
HXLINE( 137)						int color = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 137)						{
HXLINE( 137)							color = ((int)color & (int)(int)-16711681);
HXDLIN( 137)							int color1;
HXDLIN( 137)							if ((resultRed > (int)255)) {
HXLINE( 137)								color1 = (int)255;
            							}
            							else {
HXLINE( 137)								if ((resultRed < (int)0)) {
HXLINE( 137)									color1 = (int)0;
            								}
            								else {
HXLINE( 137)									color1 = resultRed;
            								}
            							}
HXDLIN( 137)							color = ((int)color | (int)((int)color1 << (int)(int)16));
            						}
HXDLIN( 137)						{
HXLINE( 137)							color = ((int)color & (int)(int)-65281);
HXDLIN( 137)							int color2;
HXDLIN( 137)							if ((resultGreen > (int)255)) {
HXLINE( 137)								color2 = (int)255;
            							}
            							else {
HXLINE( 137)								if ((resultGreen < (int)0)) {
HXLINE( 137)									color2 = (int)0;
            								}
            								else {
HXLINE( 137)									color2 = resultGreen;
            								}
            							}
HXDLIN( 137)							color = ((int)color | (int)((int)color2 << (int)(int)8));
            						}
HXDLIN( 137)						{
HXLINE( 137)							color = ((int)color & (int)(int)-256);
HXDLIN( 137)							int color3;
HXDLIN( 137)							if ((resultBlue > (int)255)) {
HXLINE( 137)								color3 = (int)255;
            							}
            							else {
HXLINE( 137)								if ((resultBlue < (int)0)) {
HXLINE( 137)									color3 = (int)0;
            								}
            								else {
HXLINE( 137)									color3 = resultBlue;
            								}
            							}
HXDLIN( 137)							color = ((int)color | (int)color3);
            						}
HXDLIN( 137)						{
HXLINE( 137)							color = ((int)color & (int)(int)16777215);
HXDLIN( 137)							int color4;
HXDLIN( 137)							if ((resultAlpha > (int)255)) {
HXLINE( 137)								color4 = (int)255;
            							}
            							else {
HXLINE( 137)								if ((resultAlpha < (int)0)) {
HXLINE( 137)									color4 = (int)0;
            								}
            								else {
HXLINE( 137)									color4 = resultAlpha;
            								}
            							}
HXDLIN( 137)							color = ((int)color | (int)((int)color4 << (int)(int)24));
            						}
HXDLIN( 137)						resultColor = color;
HXLINE( 140)						destBitmapData->setPixel32(currX,currY,resultColor);
            					}
            				}
            			}
            		}
HXLINE( 143)		destBitmapData->unlock(null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(FlxBitmapDataUtil_obj,merge,(void))

int FlxBitmapDataUtil_obj::mergeColorComponent(int source,int dest,int multiplier){
            	HX_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_149_mergeColorComponent)
HXDLIN( 149)		return ::Std_obj::_hx_int(((Float)((source * multiplier) + (dest * ((int)256 - multiplier))) / (Float)(int)256));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(FlxBitmapDataUtil_obj,mergeColorComponent,return )

 ::Dynamic FlxBitmapDataUtil_obj::compare( ::openfl::_legacy::display::BitmapData Bitmap1, ::openfl::_legacy::display::BitmapData Bitmap2){
            	HX_GC_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_164_compare)
HXLINE( 168)		if (hx::IsEq( Bitmap1,Bitmap2 )) {
HXLINE( 170)			return (int)0;
            		}
HXLINE( 172)		int _hx_tmp = Bitmap1->get_width();
HXDLIN( 172)		if ((_hx_tmp != Bitmap2->get_width())) {
HXLINE( 174)			return (int)-3;
            		}
            		else {
HXLINE( 176)			int _hx_tmp1 = Bitmap1->get_height();
HXDLIN( 176)			if ((_hx_tmp1 != Bitmap2->get_height())) {
HXLINE( 178)				return (int)-4;
            			}
            			else {
HXLINE( 182)				int width = Bitmap1->get_width();
HXLINE( 183)				int height = Bitmap1->get_height();
HXLINE( 184)				 ::openfl::_legacy::display::BitmapData result =  ::openfl::_legacy::display::BitmapData_obj::__alloc( HX_CTX ,width,height,true,(int)0,null());
HXLINE( 185)				bool identical = true;
HXLINE( 187)				{
HXLINE( 187)					int _g1 = (int)0;
HXDLIN( 187)					int _g = width;
HXDLIN( 187)					while((_g1 < _g)){
HXLINE( 187)						_g1 = (_g1 + (int)1);
HXDLIN( 187)						int i = (_g1 - (int)1);
HXLINE( 189)						{
HXLINE( 189)							int _g3 = (int)0;
HXDLIN( 189)							int _g2 = height;
HXDLIN( 189)							while((_g3 < _g2)){
HXLINE( 189)								_g3 = (_g3 + (int)1);
HXDLIN( 189)								int j = (_g3 - (int)1);
HXLINE( 191)								int pixel1 = Bitmap1->getPixel32(i,j);
HXLINE( 192)								int pixel2 = Bitmap2->getPixel32(i,j);
HXLINE( 194)								if ((pixel1 != pixel2)) {
HXLINE( 196)									identical = false;
HXLINE( 198)									if ((((int)pixel1 & (int)(int)16777215) != ((int)pixel2 & (int)(int)16777215))) {
HXLINE( 201)										int diff = (((int)((int)pixel1 >> (int)(int)16) & (int)(int)255) - ((int)((int)pixel2 >> (int)(int)16) & (int)(int)255));
HXLINE( 200)										int Red;
HXLINE( 201)										if ((diff >= (int)0)) {
HXLINE( 200)											Red = diff;
            										}
            										else {
HXLINE( 200)											Red = ((int)256 + diff);
            										}
HXLINE( 202)										int diff1 = (((int)((int)pixel1 >> (int)(int)8) & (int)(int)255) - ((int)((int)pixel2 >> (int)(int)8) & (int)(int)255));
HXLINE( 200)										int Green;
HXLINE( 202)										if ((diff1 >= (int)0)) {
HXLINE( 200)											Green = diff1;
            										}
            										else {
HXLINE( 200)											Green = ((int)256 + diff1);
            										}
HXLINE( 203)										int diff2 = (((int)pixel1 & (int)(int)255) - ((int)pixel2 & (int)(int)255));
HXLINE( 200)										int Blue;
HXLINE( 203)										if ((diff2 >= (int)0)) {
HXLINE( 200)											Blue = diff2;
            										}
            										else {
HXLINE( 200)											Blue = ((int)256 + diff2);
            										}
HXDLIN( 200)										int Alpha = (int)255;
HXDLIN( 200)										int color = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 200)										{
HXLINE( 200)											color = ((int)color & (int)(int)-16711681);
HXDLIN( 200)											int color1;
HXDLIN( 200)											if ((Red > (int)255)) {
HXLINE( 200)												color1 = (int)255;
            											}
            											else {
HXLINE( 200)												if ((Red < (int)0)) {
HXLINE( 200)													color1 = (int)0;
            												}
            												else {
HXLINE( 200)													color1 = Red;
            												}
            											}
HXDLIN( 200)											color = ((int)color | (int)((int)color1 << (int)(int)16));
            										}
HXDLIN( 200)										{
HXLINE( 200)											color = ((int)color & (int)(int)-65281);
HXDLIN( 200)											int color2;
HXDLIN( 200)											if ((Green > (int)255)) {
HXLINE( 200)												color2 = (int)255;
            											}
            											else {
HXLINE( 200)												if ((Green < (int)0)) {
HXLINE( 200)													color2 = (int)0;
            												}
            												else {
HXLINE( 200)													color2 = Green;
            												}
            											}
HXDLIN( 200)											color = ((int)color | (int)((int)color2 << (int)(int)8));
            										}
HXDLIN( 200)										{
HXLINE( 200)											color = ((int)color & (int)(int)-256);
HXDLIN( 200)											int color3;
HXDLIN( 200)											if ((Blue > (int)255)) {
HXLINE( 200)												color3 = (int)255;
            											}
            											else {
HXLINE( 200)												if ((Blue < (int)0)) {
HXLINE( 200)													color3 = (int)0;
            												}
            												else {
HXLINE( 200)													color3 = Blue;
            												}
            											}
HXDLIN( 200)											color = ((int)color | (int)color3);
            										}
HXDLIN( 200)										{
HXLINE( 200)											color = ((int)color & (int)(int)16777215);
HXDLIN( 200)											int color4;
HXDLIN( 200)											if ((Alpha > (int)255)) {
HXLINE( 200)												color4 = (int)255;
            											}
            											else {
HXLINE( 200)												if ((Alpha < (int)0)) {
HXLINE( 200)													color4 = (int)0;
            												}
            												else {
HXLINE( 200)													color4 = Alpha;
            												}
            											}
HXDLIN( 200)											color = ((int)color | (int)((int)color4 << (int)(int)24));
            										}
HXDLIN( 200)										result->setPixel32(i,j,color);
            									}
            									else {
HXLINE( 208)										int alpha1 = ((int)((int)pixel1 >> (int)(int)24) & (int)(int)255);
HXLINE( 209)										int alpha2 = ((int)((int)pixel2 >> (int)(int)24) & (int)(int)255);
HXLINE( 211)										if ((alpha1 != alpha2)) {
HXLINE( 214)											int diff3 = (alpha1 - alpha2);
HXLINE( 213)											int Alpha1;
HXLINE( 214)											if ((diff3 >= (int)0)) {
HXLINE( 213)												Alpha1 = diff3;
            											}
            											else {
HXLINE( 213)												Alpha1 = ((int)256 + diff3);
            											}
HXDLIN( 213)											int color5 = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 213)											{
HXLINE( 213)												color5 = ((int)color5 & (int)(int)-16711681);
HXDLIN( 213)												color5 = ((int)color5 | (int)(int)16711680);
            											}
HXDLIN( 213)											{
HXLINE( 213)												color5 = ((int)color5 & (int)(int)-65281);
HXDLIN( 213)												color5 = ((int)color5 | (int)(int)65280);
            											}
HXDLIN( 213)											{
HXLINE( 213)												color5 = ((int)color5 & (int)(int)-256);
HXDLIN( 213)												color5 = ((int)color5 | (int)(int)255);
            											}
HXDLIN( 213)											{
HXLINE( 213)												color5 = ((int)color5 & (int)(int)16777215);
HXDLIN( 213)												int color6;
HXDLIN( 213)												if ((Alpha1 > (int)255)) {
HXLINE( 213)													color6 = (int)255;
            												}
            												else {
HXLINE( 213)													if ((Alpha1 < (int)0)) {
HXLINE( 213)														color6 = (int)0;
            													}
            													else {
HXLINE( 213)														color6 = Alpha1;
            													}
            												}
HXDLIN( 213)												color5 = ((int)color5 | (int)((int)color6 << (int)(int)24));
            											}
HXDLIN( 213)											result->setPixel32(i,j,color5);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXLINE( 221)				if (!(identical)) {
HXLINE( 223)					return result;
            				}
            			}
            		}
HXLINE( 227)		return (int)0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxBitmapDataUtil_obj,compare,return )

int FlxBitmapDataUtil_obj::getDiff(int value1,int value2){
            	HX_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_232_getDiff)
HXLINE( 233)		int diff = (value1 - value2);
HXLINE( 234)		if ((diff >= (int)0)) {
HXLINE( 234)			return diff;
            		}
            		else {
HXLINE( 234)			return ((int)256 + diff);
            		}
HXDLIN( 234)		return (int)0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxBitmapDataUtil_obj,getDiff,return )

Float FlxBitmapDataUtil_obj::getMemorySize( ::openfl::_legacy::display::BitmapData bitmapData){
            	HX_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_242_getMemorySize)
HXDLIN( 242)		int _hx_tmp = bitmapData->get_width();
HXDLIN( 242)		return ((_hx_tmp * bitmapData->get_height()) * (int)4);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapDataUtil_obj,getMemorySize,return )

::Array< ::Dynamic> FlxBitmapDataUtil_obj::replaceColor( ::openfl::_legacy::display::BitmapData bitmapData,int color,int newColor,hx::Null< bool >  __o_fetchPositions, ::flixel::math::FlxRect rect){
bool fetchPositions = __o_fetchPositions.Default(false);
            	HX_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_257_replaceColor)
HXLINE( 258)		::Array< ::Dynamic> positions = null();
HXLINE( 259)		if (fetchPositions) {
HXLINE( 261)			positions = ::Array_obj< ::Dynamic>::__new();
            		}
HXLINE( 264)		int startX = (int)0;
HXLINE( 265)		int startY = (int)0;
HXLINE( 266)		int columns = bitmapData->get_width();
HXLINE( 267)		int rows = bitmapData->get_height();
HXLINE( 269)		if (hx::IsNotNull( rect )) {
HXLINE( 271)			startX = ::Std_obj::_hx_int(rect->x);
HXLINE( 272)			startY = ::Std_obj::_hx_int(rect->y);
HXLINE( 273)			columns = ::Std_obj::_hx_int(rect->width);
HXLINE( 274)			rows = ::Std_obj::_hx_int(rect->height);
            		}
HXLINE( 277)		columns = ::Std_obj::_hx_int(::Math_obj::max(columns,bitmapData->get_width()));
HXLINE( 278)		rows = ::Std_obj::_hx_int(::Math_obj::max(rows,bitmapData->get_height()));
HXLINE( 280)		int row = (int)0;
HXLINE( 281)		int column = (int)0;
HXLINE( 282)		int x;
HXDLIN( 282)		int y;
HXLINE( 284)		bool changed = false;
HXLINE( 285)		bitmapData->lock();
HXLINE( 286)		while((row < rows)){
HXLINE( 288)			column = (int)0;
HXLINE( 289)			while((column < columns)){
HXLINE( 291)				x = (startX + column);
HXLINE( 292)				y = (startY + row);
HXLINE( 293)				if ((bitmapData->getPixel32(x,y) == color)) {
HXLINE( 295)					bitmapData->setPixel32(x,y,newColor);
HXLINE( 296)					changed = true;
HXLINE( 297)					if (fetchPositions) {
HXLINE( 299)						 ::flixel::math::FlxPoint point = ::flixel::math::FlxPoint_obj::_pool->get()->set(x,y);
HXDLIN( 299)						point->_inPool = false;
HXDLIN( 299)						positions->push(point);
            					}
            				}
HXLINE( 302)				column = (column + (int)1);
            			}
HXLINE( 304)			row = (row + (int)1);
            		}
HXLINE( 306)		bitmapData->unlock(null());
HXLINE( 308)		bool _hx_tmp;
HXDLIN( 308)		if (changed) {
HXLINE( 308)			_hx_tmp = hx::IsNull( positions );
            		}
            		else {
HXLINE( 308)			_hx_tmp = false;
            		}
HXDLIN( 308)		if (_hx_tmp) {
HXLINE( 310)			positions = ::Array_obj< ::Dynamic>::__new();
            		}
HXLINE( 313)		return positions;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(FlxBitmapDataUtil_obj,replaceColor,return )

 ::openfl::_legacy::display::BitmapData FlxBitmapDataUtil_obj::addSpacesAndBorders( ::openfl::_legacy::display::BitmapData bitmapData, ::flixel::math::FlxPoint frameSize, ::flixel::math::FlxPoint spacing, ::flixel::math::FlxPoint border, ::flixel::math::FlxRect region){
            	HX_GC_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_326_addSpacesAndBorders)
HXLINE( 327)		if (hx::IsNull( region )) {
HXLINE( 329)			Float Width = bitmapData->get_width();
HXDLIN( 329)			Float Height = bitmapData->get_height();
HXDLIN( 329)			 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 329)			_this->x = (int)0;
HXDLIN( 329)			_this->y = (int)0;
HXDLIN( 329)			_this->width = Width;
HXDLIN( 329)			_this->height = Height;
HXDLIN( 329)			 ::flixel::math::FlxRect rect = _this;
HXDLIN( 329)			rect->_inPool = false;
HXDLIN( 329)			region = rect;
            		}
HXLINE( 332)		int frameWidth = ::Std_obj::_hx_int(region->width);
HXLINE( 333)		int frameHeight = ::Std_obj::_hx_int(region->height);
HXLINE( 335)		if (hx::IsNotNull( frameSize )) {
HXLINE( 337)			frameWidth = ::Std_obj::_hx_int(frameSize->x);
HXLINE( 338)			frameHeight = ::Std_obj::_hx_int(frameSize->y);
            		}
HXLINE( 341)		int numHorizontalFrames = ::Std_obj::_hx_int(((Float)region->width / (Float)frameWidth));
HXLINE( 342)		int numVerticalFrames = ::Std_obj::_hx_int(((Float)region->height / (Float)frameHeight));
HXLINE( 344)		int spaceX = (int)0;
HXLINE( 345)		int spaceY = (int)0;
HXLINE( 347)		if (hx::IsNotNull( spacing )) {
HXLINE( 349)			spaceX = ::Std_obj::_hx_int(spacing->x);
HXLINE( 350)			spaceY = ::Std_obj::_hx_int(spacing->y);
            		}
HXLINE( 353)		int borderX = (int)0;
HXLINE( 354)		int borderY = (int)0;
HXLINE( 356)		if (hx::IsNotNull( border )) {
HXLINE( 358)			borderX = ::Std_obj::_hx_int(border->x);
HXLINE( 359)			borderY = ::Std_obj::_hx_int(border->y);
            		}
HXLINE( 363)		Float region1 = region->width;
HXDLIN( 363)		Float result = (region1 + ((numHorizontalFrames - (int)1) * spaceX));
HXDLIN( 363)		int result1 = ::Std_obj::_hx_int((result + (((int)2 * numHorizontalFrames) * borderX)));
HXLINE( 364)		Float region2 = region->height;
HXDLIN( 364)		Float result2 = (region2 + ((numVerticalFrames - (int)1) * spaceY));
HXLINE( 362)		 ::openfl::_legacy::display::BitmapData result3 =  ::openfl::_legacy::display::BitmapData_obj::__alloc( HX_CTX ,result1,::Std_obj::_hx_int((result2 + (((int)2 * numVerticalFrames) * borderY))),true,(int)0,null());
HXLINE( 368)		result3->lock();
HXLINE( 369)		 ::openfl::_legacy::geom::Rectangle tempRect =  ::openfl::_legacy::geom::Rectangle_obj::__alloc( HX_CTX ,(int)0,(int)0,frameWidth,frameHeight);
HXLINE( 370)		 ::openfl::_legacy::geom::Point tempPoint =  ::openfl::_legacy::geom::Point_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 373)		{
HXLINE( 373)			int _g1 = (int)0;
HXDLIN( 373)			int _g = numHorizontalFrames;
HXDLIN( 373)			while((_g1 < _g)){
HXLINE( 373)				_g1 = (_g1 + (int)1);
HXDLIN( 373)				int i = (_g1 - (int)1);
HXLINE( 375)				tempPoint->x = ((i * ((frameWidth + spaceX) + ((int)2 * borderX))) + borderX);
HXLINE( 376)				tempRect->x = ((i * frameWidth) + region->x);
HXLINE( 378)				{
HXLINE( 378)					int _g3 = (int)0;
HXDLIN( 378)					int _g2 = numVerticalFrames;
HXDLIN( 378)					while((_g3 < _g2)){
HXLINE( 378)						_g3 = (_g3 + (int)1);
HXDLIN( 378)						int j = (_g3 - (int)1);
HXLINE( 380)						tempPoint->y = ((j * ((frameHeight + spaceY) + ((int)2 * borderY))) + borderY);
HXLINE( 381)						tempRect->y = ((j * frameHeight) + region->y);
HXLINE( 382)						result3->copyPixels(bitmapData,tempRect,tempPoint,null(),null(),null());
            					}
            				}
            			}
            		}
HXLINE( 385)		result3->unlock(null());
HXLINE( 388)		::flixel::util::FlxBitmapDataUtil_obj::copyBorderPixels(result3,frameWidth,frameHeight,spaceX,spaceY,borderX,borderY,numHorizontalFrames,numVerticalFrames);
HXLINE( 389)		return result3;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(FlxBitmapDataUtil_obj,addSpacesAndBorders,return )

 ::openfl::_legacy::display::BitmapData FlxBitmapDataUtil_obj::copyBorderPixels( ::openfl::_legacy::display::BitmapData bitmapData,int frameWidth,int frameHeight,int spaceX,int spaceY,int borderX,int borderY,int horizontalFrames,int verticalFrames){
            	HX_GC_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_409_copyBorderPixels)
HXLINE( 411)		 ::openfl::_legacy::geom::Rectangle tempRect =  ::openfl::_legacy::geom::Rectangle_obj::__alloc( HX_CTX ,(int)0,(int)0,(int)1,bitmapData->get_height());
HXLINE( 412)		 ::openfl::_legacy::geom::Point tempPoint =  ::openfl::_legacy::geom::Point_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 413)		bitmapData->lock();
HXLINE( 415)		{
HXLINE( 415)			int _g1 = (int)0;
HXDLIN( 415)			int _g = horizontalFrames;
HXDLIN( 415)			while((_g1 < _g)){
HXLINE( 415)				_g1 = (_g1 + (int)1);
HXDLIN( 415)				int i = (_g1 - (int)1);
HXLINE( 417)				tempRect->x = ((i * ((frameWidth + ((int)2 * borderX)) + spaceX)) + borderX);
HXLINE( 419)				{
HXLINE( 419)					int _g3 = (int)0;
HXDLIN( 419)					int _g2 = borderX;
HXDLIN( 419)					while((_g3 < _g2)){
HXLINE( 419)						_g3 = (_g3 + (int)1);
HXDLIN( 419)						int j = (_g3 - (int)1);
HXLINE( 421)						tempPoint->x = ((tempRect->x - j) - (int)1);
HXLINE( 422)						bitmapData->copyPixels(bitmapData,tempRect,tempPoint,null(),null(),null());
            					}
            				}
HXLINE( 425)				 ::openfl::_legacy::geom::Rectangle tempRect1 = tempRect;
HXDLIN( 425)				tempRect1->x = (tempRect1->x + (frameWidth - (int)1));
HXLINE( 427)				{
HXLINE( 427)					int _g31 = (int)0;
HXDLIN( 427)					int _g21 = borderX;
HXDLIN( 427)					while((_g31 < _g21)){
HXLINE( 427)						_g31 = (_g31 + (int)1);
HXDLIN( 427)						int j1 = (_g31 - (int)1);
HXLINE( 429)						tempPoint->x = ((tempRect->x + j1) + (int)1);
HXLINE( 430)						bitmapData->copyPixels(bitmapData,tempRect,tempPoint,null(),null(),null());
            					}
            				}
            			}
            		}
HXLINE( 434)		tempPoint->setTo((int)0,(int)0);
HXLINE( 435)		tempRect->setTo((int)0,(int)0,bitmapData->get_width(),(int)1);
HXLINE( 436)		{
HXLINE( 436)			int _g11 = (int)0;
HXDLIN( 436)			int _g4 = verticalFrames;
HXDLIN( 436)			while((_g11 < _g4)){
HXLINE( 436)				_g11 = (_g11 + (int)1);
HXDLIN( 436)				int i1 = (_g11 - (int)1);
HXLINE( 438)				tempRect->y = ((i1 * ((frameHeight + ((int)2 * borderY)) + spaceY)) + borderY);
HXLINE( 440)				{
HXLINE( 440)					int _g32 = (int)0;
HXDLIN( 440)					int _g22 = borderY;
HXDLIN( 440)					while((_g32 < _g22)){
HXLINE( 440)						_g32 = (_g32 + (int)1);
HXDLIN( 440)						int j2 = (_g32 - (int)1);
HXLINE( 442)						tempPoint->y = ((tempRect->y - j2) - (int)1);
HXLINE( 443)						bitmapData->copyPixels(bitmapData,tempRect,tempPoint,null(),null(),null());
            					}
            				}
HXLINE( 446)				 ::openfl::_legacy::geom::Rectangle tempRect2 = tempRect;
HXDLIN( 446)				tempRect2->y = (tempRect2->y + (frameHeight - (int)1));
HXLINE( 448)				{
HXLINE( 448)					int _g33 = (int)0;
HXDLIN( 448)					int _g23 = borderY;
HXDLIN( 448)					while((_g33 < _g23)){
HXLINE( 448)						_g33 = (_g33 + (int)1);
HXDLIN( 448)						int j3 = (_g33 - (int)1);
HXLINE( 450)						tempPoint->y = ((tempRect->y + j3) + (int)1);
HXLINE( 451)						bitmapData->copyPixels(bitmapData,tempRect,tempPoint,null(),null(),null());
            					}
            				}
            			}
            		}
HXLINE( 455)		bitmapData->unlock(null());
HXLINE( 456)		return bitmapData;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(FlxBitmapDataUtil_obj,copyBorderPixels,return )

 ::openfl::_legacy::display::BitmapData FlxBitmapDataUtil_obj::generateRotations( ::openfl::_legacy::display::BitmapData brush,hx::Null< int >  __o_rotations,hx::Null< bool >  __o_antiAliasing,hx::Null< bool >  __o_autoBuffer){
int rotations = __o_rotations.Default(16);
bool antiAliasing = __o_antiAliasing.Default(false);
bool autoBuffer = __o_autoBuffer.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_469_generateRotations)
HXLINE( 470)		int brushWidth = brush->get_width();
HXLINE( 471)		int brushHeight = brush->get_height();
HXLINE( 472)		int max;
HXDLIN( 472)		if ((brushHeight > brushWidth)) {
HXLINE( 472)			max = brushHeight;
            		}
            		else {
HXLINE( 472)			max = brushWidth;
            		}
HXLINE( 473)		if (autoBuffer) {
HXLINE( 473)			max = ::Std_obj::_hx_int((max * ((Float)1.5)));
            		}
            		else {
HXLINE( 473)			max = max;
            		}
HXLINE( 475)		int rows = ::Std_obj::_hx_int(::Math_obj::sqrt(rotations));
HXLINE( 476)		int columns = ::Math_obj::ceil(((Float)rotations / (Float)rows));
HXLINE( 477)		Float bakedRotationAngle = ((Float)(int)360 / (Float)rotations);
HXLINE( 479)		int width = (max * columns);
HXLINE( 480)		int height = (max * rows);
HXLINE( 482)		 ::openfl::_legacy::display::BitmapData result =  ::openfl::_legacy::display::BitmapData_obj::__alloc( HX_CTX ,width,height,true,(int)0,null());
HXLINE( 484)		int row = (int)0;
HXLINE( 485)		int column = (int)0;
HXLINE( 486)		Float bakedAngle = (int)0;
HXLINE( 487)		int halfBrushWidth = ::Std_obj::_hx_int((brushWidth * ((Float)0.5)));
HXLINE( 488)		int halfBrushHeight = ::Std_obj::_hx_int((brushHeight * ((Float)0.5)));
HXLINE( 489)		int midpointX = ::Std_obj::_hx_int((max * ((Float)0.5)));
HXLINE( 490)		int midpointY = ::Std_obj::_hx_int((max * ((Float)0.5)));
HXLINE( 492)		while((row < rows)){
HXLINE( 494)			column = (int)0;
HXLINE( 495)			while((column < columns)){
HXLINE( 497)				::flixel::util::FlxBitmapDataUtil_obj::matrix->identity();
HXLINE( 498)				::flixel::util::FlxBitmapDataUtil_obj::matrix->translate(-(halfBrushWidth),-(halfBrushHeight));
HXLINE( 499)				 ::flixel::math::FlxMatrix _hx_tmp = ::flixel::util::FlxBitmapDataUtil_obj::matrix;
HXDLIN( 499)				_hx_tmp->rotate((bakedAngle * ((Float)::Math_obj::PI / (Float)(int)180)));
HXLINE( 500)				 ::flixel::math::FlxMatrix _hx_tmp1 = ::flixel::util::FlxBitmapDataUtil_obj::matrix;
HXDLIN( 500)				_hx_tmp1->translate(((max * column) + midpointX),midpointY);
HXLINE( 501)				bakedAngle = (bakedAngle + bakedRotationAngle);
HXLINE( 502)				result->draw(brush,::flixel::util::FlxBitmapDataUtil_obj::matrix,null(),null(),null(),antiAliasing);
HXLINE( 503)				column = (column + (int)1);
            			}
HXLINE( 505)			midpointY = (midpointY + max);
HXLINE( 506)			row = (row + (int)1);
            		}
HXLINE( 509)		return result;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(FlxBitmapDataUtil_obj,generateRotations,return )


FlxBitmapDataUtil_obj::FlxBitmapDataUtil_obj()
{
}

bool FlxBitmapDataUtil_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"merge") ) { outValue = merge_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"matrix") ) { outValue = ( matrix ); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"compare") ) { outValue = compare_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getDiff") ) { outValue = getDiff_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"replaceColor") ) { outValue = replaceColor_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"getMemorySize") ) { outValue = getMemorySize_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"copyBorderPixels") ) { outValue = copyBorderPixels_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"generateRotations") ) { outValue = generateRotations_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"mergeColorComponent") ) { outValue = mergeColorComponent_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"addSpacesAndBorders") ) { outValue = addSpacesAndBorders_dyn(); return true; }
	}
	return false;
}

bool FlxBitmapDataUtil_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"matrix") ) { matrix=ioValue.Cast<  ::flixel::math::FlxMatrix >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *FlxBitmapDataUtil_obj_sMemberStorageInfo = 0;
static hx::StaticInfo FlxBitmapDataUtil_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::flixel::math::FlxMatrix*/ ,(void *) &FlxBitmapDataUtil_obj::matrix,HX_HCSTRING("matrix","\x41","\x36","\xc8","\xbb")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void FlxBitmapDataUtil_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxBitmapDataUtil_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(FlxBitmapDataUtil_obj::matrix,"matrix");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxBitmapDataUtil_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxBitmapDataUtil_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(FlxBitmapDataUtil_obj::matrix,"matrix");
};

#endif

hx::Class FlxBitmapDataUtil_obj::__mClass;

static ::String FlxBitmapDataUtil_obj_sStaticFields[] = {
	HX_HCSTRING("matrix","\x41","\x36","\xc8","\xbb"),
	HX_HCSTRING("merge","\xb8","\xa2","\xc6","\x05"),
	HX_HCSTRING("mergeColorComponent","\xb2","\x23","\x8f","\xc5"),
	HX_HCSTRING("compare","\xa5","\x18","\x69","\x83"),
	HX_HCSTRING("getDiff","\xbb","\x0b","\xec","\x14"),
	HX_HCSTRING("getMemorySize","\x98","\x08","\x07","\x4f"),
	HX_HCSTRING("replaceColor","\x8f","\x5c","\xeb","\x3d"),
	HX_HCSTRING("addSpacesAndBorders","\x7e","\x17","\x0f","\x63"),
	HX_HCSTRING("copyBorderPixels","\x8e","\x6c","\x7f","\x76"),
	HX_HCSTRING("generateRotations","\x80","\xcb","\xc6","\x62"),
	::String(null())
};

void FlxBitmapDataUtil_obj::__register()
{
	hx::Object *dummy = new FlxBitmapDataUtil_obj;
	FlxBitmapDataUtil_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("flixel.util.FlxBitmapDataUtil","\xb3","\x4e","\x39","\xe9");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &FlxBitmapDataUtil_obj::__GetStatic;
	__mClass->mSetStaticField = &FlxBitmapDataUtil_obj::__SetStatic;
	__mClass->mMarkFunc = FlxBitmapDataUtil_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(FlxBitmapDataUtil_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< FlxBitmapDataUtil_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxBitmapDataUtil_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxBitmapDataUtil_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxBitmapDataUtil_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void FlxBitmapDataUtil_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_17_boot)
HXDLIN(  17)		matrix =  ::flixel::math::FlxMatrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
            	}
}

} // end namespace flixel
} // end namespace util
