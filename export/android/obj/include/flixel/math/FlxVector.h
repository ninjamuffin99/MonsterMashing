// Generated by Haxe 3.4.7
#ifndef INCLUDED_flixel_math_FlxVector
#define INCLUDED_flixel_math_FlxVector

#ifndef HXCPP_H
#include <hxcpp.h>
#endif

#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
HX_DECLARE_CLASS2(flixel,math,FlxPoint)
HX_DECLARE_CLASS2(flixel,math,FlxVector)
HX_DECLARE_CLASS2(flixel,util,FlxPool_flixel_math_FlxVector)
HX_DECLARE_CLASS2(flixel,util,IFlxDestroyable)
HX_DECLARE_CLASS2(flixel,util,IFlxPool)
HX_DECLARE_CLASS2(flixel,util,IFlxPooled)

namespace flixel{
namespace math{


class HXCPP_CLASS_ATTRIBUTES FlxVector_obj : public  ::flixel::math::FlxPoint_obj
{
	public:
		typedef  ::flixel::math::FlxPoint_obj super;
		typedef FlxVector_obj OBJ_;
		FlxVector_obj();

	public:
		enum { _hx_ClassId = 0x30935e91 };

		void __construct( ::Dynamic X, ::Dynamic Y);
		inline void *operator new(size_t inSize, bool inContainer=false,const char *inName="flixel.math.FlxVector")
			{ return hx::Object::operator new(inSize,inContainer,inName); }
		inline void *operator new(size_t inSize, int extra)
			{ return hx::Object::operator new(inSize+extra,false,"flixel.math.FlxVector"); }
		static hx::ObjectPtr< FlxVector_obj > __new( ::Dynamic X, ::Dynamic Y);
		static hx::ObjectPtr< FlxVector_obj > __alloc(hx::Ctx *_hx_ctx, ::Dynamic X, ::Dynamic Y);
		static void * _hx_vtable;
		static Dynamic __CreateEmpty();
		static Dynamic __Create(hx::DynamicArray inArgs);
		//~FlxVector_obj();

		HX_DO_RTTI_ALL;
		hx::Val __Field(const ::String &inString, hx::PropertyAccess inCallProp);
		static bool __GetStatic(const ::String &inString, Dynamic &outValue, hx::PropertyAccess inCallProp);
		hx::Val __SetField(const ::String &inString,const hx::Val &inValue, hx::PropertyAccess inCallProp);
		static bool __SetStatic(const ::String &inString, Dynamic &ioValue, hx::PropertyAccess inCallProp);
		void __GetFields(Array< ::String> &outFields);
		static void __register();
		bool _hx_isInstanceOf(int inClassId);
		::String __ToString() const { return HX_HCSTRING("FlxVector","\xb5","\xaa","\x4c","\x19"); }

		static void __boot();
		static Float EPSILON;
		static Float EPSILON_SQUARED;
		static  ::flixel::util::FlxPool_flixel_math_FlxVector _pool;
		static  ::flixel::math::FlxVector _vector1;
		static  ::flixel::math::FlxVector _vector2;
		static  ::flixel::math::FlxVector _vector3;
		static  ::flixel::math::FlxVector get(hx::Null< Float >  X,hx::Null< Float >  Y);
		static ::Dynamic get_dyn();

		void put();

		 ::flixel::math::FlxPoint set(hx::Null< Float >  X,hx::Null< Float >  Y);

		 ::flixel::math::FlxPoint scale(Float k);

		 ::flixel::math::FlxVector scaleNew(Float k);
		::Dynamic scaleNew_dyn();

		 ::flixel::math::FlxVector addNew( ::flixel::math::FlxVector v);
		::Dynamic addNew_dyn();

		 ::flixel::math::FlxVector subtractNew( ::flixel::math::FlxVector v);
		::Dynamic subtractNew_dyn();

		Float dotProduct( ::flixel::math::FlxVector v);
		::Dynamic dotProduct_dyn();

		Float dotProdWithNormalizing( ::flixel::math::FlxVector v);
		::Dynamic dotProdWithNormalizing_dyn();

		bool isPerpendicular( ::flixel::math::FlxVector v);
		::Dynamic isPerpendicular_dyn();

		Float crossProductLength( ::flixel::math::FlxVector v);
		::Dynamic crossProductLength_dyn();

		bool isParallel( ::flixel::math::FlxVector v);
		::Dynamic isParallel_dyn();

		bool isZero();
		::Dynamic isZero_dyn();

		 ::flixel::math::FlxVector zero();
		::Dynamic zero_dyn();

		 ::flixel::math::FlxVector normalize();
		::Dynamic normalize_dyn();

		bool isNormalized();
		::Dynamic isNormalized_dyn();

		 ::flixel::math::FlxVector rotateByRadians(Float rads);
		::Dynamic rotateByRadians_dyn();

		 ::flixel::math::FlxVector rotateByDegrees(Float degs);
		::Dynamic rotateByDegrees_dyn();

		 ::flixel::math::FlxVector rotateWithTrig(Float sin,Float cos);
		::Dynamic rotateWithTrig_dyn();

		 ::flixel::math::FlxVector rightNormal( ::flixel::math::FlxVector vec);
		::Dynamic rightNormal_dyn();

		 ::flixel::math::FlxVector leftNormal( ::flixel::math::FlxVector vec);
		::Dynamic leftNormal_dyn();

		 ::flixel::math::FlxVector negate();
		::Dynamic negate_dyn();

		 ::flixel::math::FlxVector negateNew();
		::Dynamic negateNew_dyn();

		 ::flixel::math::FlxVector projectTo( ::flixel::math::FlxVector v, ::flixel::math::FlxVector proj);
		::Dynamic projectTo_dyn();

		 ::flixel::math::FlxVector projectToNormalized( ::flixel::math::FlxVector v, ::flixel::math::FlxVector proj);
		::Dynamic projectToNormalized_dyn();

		Float perpProduct( ::flixel::math::FlxVector v);
		::Dynamic perpProduct_dyn();

		Float ratio( ::flixel::math::FlxVector a, ::flixel::math::FlxVector b, ::flixel::math::FlxVector v);
		::Dynamic ratio_dyn();

		 ::flixel::math::FlxVector findIntersection( ::flixel::math::FlxVector a, ::flixel::math::FlxVector b, ::flixel::math::FlxVector v, ::flixel::math::FlxVector intersection);
		::Dynamic findIntersection_dyn();

		 ::flixel::math::FlxVector findIntersectionInBounds( ::flixel::math::FlxVector a, ::flixel::math::FlxVector b, ::flixel::math::FlxVector v, ::flixel::math::FlxVector intersection);
		::Dynamic findIntersectionInBounds_dyn();

		 ::flixel::math::FlxVector truncate(Float max);
		::Dynamic truncate_dyn();

		Float radiansBetween( ::flixel::math::FlxVector v);
		::Dynamic radiansBetween_dyn();

		Float degreesBetween( ::flixel::math::FlxVector v);
		::Dynamic degreesBetween_dyn();

		int sign( ::flixel::math::FlxVector a, ::flixel::math::FlxVector b);
		::Dynamic sign_dyn();

		Float dist( ::flixel::math::FlxVector v);
		::Dynamic dist_dyn();

		Float distSquared( ::flixel::math::FlxVector v);
		::Dynamic distSquared_dyn();

		 ::flixel::math::FlxVector bounce( ::flixel::math::FlxVector normal,hx::Null< Float >  bounceCoeff);
		::Dynamic bounce_dyn();

		 ::flixel::math::FlxVector bounceWithFriction( ::flixel::math::FlxVector normal,hx::Null< Float >  bounceCoeff,hx::Null< Float >  friction);
		::Dynamic bounceWithFriction_dyn();

		bool isValid();
		::Dynamic isValid_dyn();

		 ::flixel::math::FlxVector clone( ::flixel::math::FlxVector vec);
		::Dynamic clone_dyn();

		Float get_dx();
		::Dynamic get_dx_dyn();

		Float get_dy();
		::Dynamic get_dy_dyn();

		Float get_length();
		::Dynamic get_length_dyn();

		Float set_length(Float l);
		::Dynamic set_length_dyn();

		Float get_lengthSquared();
		::Dynamic get_lengthSquared_dyn();

		Float get_degrees();
		::Dynamic get_degrees_dyn();

		Float set_degrees(Float degs);
		::Dynamic set_degrees_dyn();

		Float get_radians();
		::Dynamic get_radians_dyn();

		Float set_radians(Float rads);
		::Dynamic set_radians_dyn();

		Float get_rx();
		::Dynamic get_rx_dyn();

		Float get_ry();
		::Dynamic get_ry_dyn();

		Float get_lx();
		::Dynamic get_lx_dyn();

		Float get_ly();
		::Dynamic get_ly_dyn();

};

} // end namespace flixel
} // end namespace math

#endif /* INCLUDED_flixel_math_FlxVector */ 
